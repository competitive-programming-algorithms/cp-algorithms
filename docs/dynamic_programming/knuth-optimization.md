# კნუტის ოპტიმიზაცია

Knuth-ის ოპტიმიზაცია, ასევე ცნობილი როგორც Knuth-Yao Speedup, არის დინამიური პროგრამირების განსაკუთრებული შემთხვევა დიაპაზონებზე, რომელსაც შეუძლია ამონახსნების დროის სირთულის ოპტიმიზაცია წრფივი ფაქტორით, $O(n^3)$-დან სტანდარტული დიაპაზონისთვის DP-დან $-მდე. O(n^2)$.

## პირობები

Speedup გამოიყენება ფორმის გადასვლებისთვის


$$dp(i, j) = \min_{i \leq k < j} [ dp(i, k) + dp(k+1, j) + C(i, j) ].$$

[divide and conquer DP](./divide-and-conquer-dp.md)-ის მსგავსად, მოდით, $opt(i, j)$ იყოს $k$-ის მნიშვნელობა, რომელიც ამცირებს გამონათქვამს გარდამავალში ($opt$ არის მოხსენიებულია, როგორც "ოპტიმალური გაყოფის წერტილი" შემდგომ ამ სტატიაში). ოპტიმიზაცია მოითხოვს შემდეგს:

$$opt(i, j-1) \leq opt(i, j) \leq opt(i+1, j).$$

ჩვენ შეგვიძლია ვაჩვენოთ, რომ ეს მართალია, როდესაც ხარჯების ფუნქცია $C$ აკმაყოფილებს შემდეგ პირობებს $a \leq b \leq c \leq d$-სთვის:

1. $C(b, c) \leq C(a, d)$;

2. $C(a, c) + C(b, d) \leq C(a, d) + C(b, c)$ (ოთხკუთხედის უტოლობა [QI]).

ეს შედეგი დადასტურებულია ქვემოთ.

## ალგორითმი

მოდით დავამუშავოთ dp მდგომარეობები ისე, რომ გამოვთვალოთ $dp(i, j-1)$ და $dp(i+1, j)$ $dp(i, j)$-მდე და ამით ჩვენ ასევე გამოვთვალოთ $opt(i, j-1)$ და $opt(i+1, j)$. შემდეგ $opt(i, j)$-ის გამოსათვლელად, ნაცვლად $k$-ის მნიშვნელობების ტესტირებისა $i$-დან $j-1$-მდე, ჩვენ მხოლოდ უნდა შევამოწმოთ $opt(i, j-1)$-დან $opt-მდე. (i+1, j)$. $(i,j)$ წყვილების ამ თანმიმდევრობით დასამუშავებლად საკმარისია გამოიყენოთ წყობილი მარყუჟები, რომლებშიც $i$ გადადის მაქსიმალური მნიშვნელობიდან მინიმუმამდე და $j$ გადადის $i+1$-დან მაქსიმალურ მნიშვნელობამდე. .

### ზოგადი განხორციელება

მიუხედავად იმისა, რომ განხორციელება განსხვავდება, აქ არის საკმაოდ ზოგადი
მაგალითი. კოდის სტრუქტურა თითქმის იდენტურია Range DP-ის.

```{.cpp file=knuth_optimization}

int solve() {
    int N;
    ... // read N and input
    int dp[N][N], opt[N][N];

    auto C = [&](int i, int j) {
        ... // Implement cost function C.
    };

    for (int i = 0; i < N; i++) {
        opt[i][i] = i;
        ... // Initialize dp[i][i] according to the problem
    }

    for (int i = N-2; i >= 0; i--) {
        for (int j = i+1; j < N; j++) {
            int mn = INT_MAX;
            int cost = C(i, j);
            for (int k = opt[i][j-1]; k <= min(j-1, opt[i+1][j]); k++) {
                if (mn >= dp[i][k] + dp[k+1][j] + cost) {
                    opt[i][j] = k; 
                    mn = dp[i][k] + dp[k+1][j] + cost; 
                }
            }
            dp[i][j] = mn; 
        }
    }

    return dp[0][N-1];
}
```

### სირთულე

ალგორითმის სირთულე შეიძლება შეფასდეს შემდეგი ჯამით:

$$
\sum\limits_{i=1}^N \sum\limits_{j=i+1}^N [opt(i+1,j)-opt(i,j-1)] =
\sum\limits_{i=1}^N \sum\limits_{j=i}^{N-1} [opt(i+1,j+1)-opt(i,j)].
$$

როგორც ხედავთ, ამ გამოთქმის ტერმინების უმეტესობა არღვევს ერთმანეთს, გარდა დადებითი ტერმინებისა $j=N$-ით და უარყოფითი ტერმინებისა $i=1$-ით. ამრიგად, მთლიანი თანხა შეიძლება შეფასდეს როგორც

$$
\sum\limits_{k=1}^N[opt(k,N)-opt(1,k)] = O(n^2),
$$

ვიდრე $O(n^3)$, როგორც ეს იქნებოდა, თუ ვიყენებდით ჩვეულებრივ დიაპაზონს DP.

### პრაქტიკაში

Knuth-ის ოპტიმიზაციის ყველაზე გავრცელებული გამოყენება არის Range DP-ში მოცემული გადასვლით. ერთადერთი სირთულე არის იმის მტკიცება, რომ ღირებულება ფუნქცია აკმაყოფილებს მოცემულ პირობებს. უმარტივესი შემთხვევაა, როდესაც ხარჯების ფუნქცია $C(i, j)$ უბრალოდ არის $S[i, i+1, ..., j]$ ქვემაივის ელემენტების ჯამი ზოგიერთი მასივისთვის (დამოკიდებულია კითხვაზე. ). თუმცა, ზოგჯერ ისინი შეიძლება უფრო რთული იყოს.


გაითვალისწინეთ, რომ უფრო მეტი, ვიდრე dp გადასვლის პირობები და ხარჯების ფუნქცია, ამ ოპტიმიზაციის გასაღები არის ოპტიმალური გაყოფის წერტილის უთანასწორობა. ზოგიერთ პრობლემაში, როგორიცაა ოპტიმალური ორობითი საძიებო ხის პრობლემა (რომელიც, სხვათა შორის, თავდაპირველი პრობლემაა, რომლისთვისაც შეიქმნა ეს ოპტიმიზაცია), გადასვლები და ხარჯების ფუნქციები ნაკლებად აშკარა იქნება, თუმცა, მაინც შეიძლება დაამტკიცოს, რომ $opt(i) , j-1) \leq opt(i, j) \leq opt(i+1, j)$ და, ამრიგად, გამოიყენეთ ეს ოპტიმიზაცია.


### სისწორის დადასტურება

ამ ალგორითმის სისწორის დასამტკიცებლად $C(i,j)$ პირობების მიხედვით, საკმარისია იმის დასამტკიცებლად, რომ

$$
opt(i, j-1) \leq opt(i, j) \leq opt(i+1, j)
$$

მოცემული პირობების დაკმაყოფილების გათვალისწინებით.

!!! ლემა "ლემა"
    $dp(i, j)$ ასევე აკმაყოფილებს ოთხკუთხედის უტოლობას, პრობლემის პირობების დაკმაყოფილების გათვალისწინებით.

??? მინიშნება "მტკიცებულება"
    ამ ლემის მტკიცებულება იყენებს ძლიერ ინდუქციას. ის აღებულია ნაშრომიდან <a href="https://dl.acm.org/doi/pdf/10.1145/800141.804691">ეფექტური დინამიური პროგრამირება ოთხკუთხედი უტოლობების გამოყენებით</a>, რომლის ავტორია ფ. ფრენსის იაო. გააცნო Knuth-Yao Speedup (ეს კონკრეტული განცხადება არის Lemma 2.1 ნაშრომში). იდეა არის $l = d - a$ სიგრძის ინდუქცია. შემთხვევა, როდესაც $l = 1$ არის ტრივიალური. $l> 1$-ისთვის განიხილეთ 2 შემთხვევა:

    1. $b = c$  
    უტოლობა მცირდება $dp(a, b) + dp(b, d) \leq dp(a, d)$ (ეს ვარაუდობს, რომ $dp(i, i) = 0$ ყველა $i$-ისთვის, რაც არის ამ ოპტიმიზაციის გამოყენებით ყველა პრობლემის შემთხვევაში). მოდით $opt(a,d) = z$.

        - If $z < j$,  
        გაითვალისწინე
        
            $$
            dp(a, b) \leq dp_{z}(a, b) = dp(a, z) + dp(z+1, b) + C(a, b).
            $$
            
            ამიტომ,  
            
            $$
            dp(a, b) + dp(b, d) \leq dp(a, z) + dp(z+1, b) + dp(b, d) + C(a, b)
            $$

           ინდუქციური ჰიპოთეზიდან $dp(z+1, b) + dp(b, d) \leq dp(z+1, d)$. ასევე, მოცემულია, რომ $C(a, b) \leq C(a, d)$. ამ 2 ფაქტის ზემოაღნიშნულ უთანასწორობასთან გაერთიანება სასურველ შედეგს იძლევა.

        - თუ $z \geq j$, ამ შემთხვევის მტკიცებულება წინა შემთხვევის სიმეტრიულია.

    2. $b < c$  
    მოდით $opt(b, c) = z$ and $opt(a, d) = y$. 
        
        - თუ $z \leq y$,  
        
            $$
            dp(a, c) + dp(b, d) \leq dp_{z}(a, c) + dp_{y}(b, d)
            $$

            სადაც

            $$
            dp_{z}(a, c) + dp_{y}(b, d) = C(a, c) + C(b, d) + dp(a, z) + dp(z+1, c) + dp(b, y) + dp(y+1, d).
            $$

            QI-ის გამოყენება $C$-ზე და dp მდგომარეობაზე $z+1 \leq y+1 \leq c \leq d$ (ინდუქციის ჰიპოთეზიდან) ინდექსებისთვის იძლევა სასურველ შედეგს.
        
        - თუ $z > y$, ამ შემთხვევის მტკიცებულება წინა შემთხვევის სიმეტრიულია.

    ეს ავსებს ლემის მტკიცებულებას.

ახლა განიხილეთ შემდეგი კონფიგურაცია. გვაქვს 2 ინდექსი $i \leq p \leq q < j$. ნაკრები $dp_{k} = C(i, j) + dp(i, k) + dp(k+1, j)$.

დავუშვათ, რომ ჩვენ ვაჩვენებთ ამას

$$
dp_{p}(i, j-1) \geq dp_{q}(i, j-1) \implies dp_{p}(i, j) \geq dp_{q}(i, j).
$$

დაყენება $q = opt(i, j-1)$, განსაზღვრებით, $dp_{p}(i, j-1) \geq dp_{q}(i, j-1)$. მაშასადამე, უტოლობის გამოყენებით ყველა $i \leq p \leq q$-ზე, შეგვიძლია დავასკვნათ, რომ $opt(i, j)$ არის მინიმუმ $opt(i, j-1)$, რაც დავადასტურებთ პირველ ნახევარს. უთანასწორობის.

ახლა, QI-ის გამოყენებით ზოგიერთ ინდექსზე $p+1 \leq q+1 \leq j-1 \leq j$, მივიღებთ

$$\begin{align}
&dp(p+1, j-1) + dp(q+1, j) ≤ dp(q+1, j-1) + dp(p+1, j) \\
\implies& (dp(i, p) + dp(p+1, j-1) + C(i, j-1)) + (dp(i, q) + dp(q+1, j) + C(i, j)) \\  
\leq& (dp(i, q) + dp(q+1, j-1) + C(i, j-1)) + (dp(i, p) + dp(p+1, j) + C(i, j)) \\  
\implies& dp_{p}(i, j-1) + dp_{q}(i, j) ≤ dp_{p}(i, j) + dp_{q}(i, j-1) \\
\implies& dp_{p}(i, j-1) - dp_{q}(i, j-1) ≤ dp_{p}(i, j) - dp_{q}(i, j) \\
\end{align}$$

საბოლოოდ,

$$\begin{align}
&dp_{p}(i, j-1) \geq dp_{q}(i, j-1) \\
&\implies 0 \leq dp_{p}(i, j-1) - dp_{q}(i, j-1) \leq dp_{p}(i, j) - dp_{q}(i, j) \\
&\implies dp_{p}(i, j) \geq dp_{q}(i, j)
\end{align}$$  

ეს ადასტურებს უტოლობის პირველ ნაწილს, ანუ $opt(i, j-1) \leq opt(i, j)$. მეორე ნაწილი $opt(i, j) \leq opt(i+1, j)$ შეიძლება ნაჩვენები იყოს იგივე იდეით, დაწყებული უტოლობით.
$dp(i, p) + dp(i+1, q) ≤ dp(i+1, p) + dp(i, q)$.

ეს ასრულებს მტკიცებულებას.

## სავარჯიშო
- [UVA - Cutting Sticks](https://onlinejudge.org/external/100/10003.pdf)
- [UVA - Prefix Codes](https://onlinejudge.org/external/120/12057.pdf)
- [SPOJ - Breaking String](https://www.spoj.com/problems/BRKSTRNG/)
- [UVA - Optimal Binary Search Tree](https://onlinejudge.org/external/103/10304.pdf)


## ცნობები
- [Geeksforgeeks Article](https://www.geeksforgeeks.org/knuths-optimization-in-dynamic-programming/)
- [Doc on DP Speedups](https://home.cse.ust.hk/~golin/COMP572/Notes/DP_speedup.pdf)
- [Efficient Dynamic Programming Using Quadrangle Inequalities](https://dl.acm.org/doi/pdf/10.1145/800141.804691)
