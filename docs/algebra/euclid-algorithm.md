# ევკლიდური ალგორითმი უდიდესი საერთო გამყოფის გამოსათვლელად
ორი არაუარყოფითი მთელი რიცხვის $a$ და $b$-ის გათვალისწინებით, ჩვენ უნდა ვიპოვოთ მათი ყველაზე დიდი საერთო გამყოფი **GCD** (greatest common divisor).
ის ჩვეულებრივ აღინიშნება $\gcd(a, b)$. მათემატიკურად ის განისაზღვრება, როგორც:

$$\gcd(a, b) = \max \{k > 0 : (k \mid a) \text{ and } (k \mid b) \}$$

(აქ სიმბოლო "$\mid$" ნიშნავს გაყოფას, ანუ, "$k \mid a$" ნიშნავს "$k$ ყოფს $a$")

როდესაც რიცხვებიდან ერთი არის ნულოვანი, ხოლო მეორე არა-ნულოვანი, მათი ყველაზე დიდი საერთო გამყოფი, განსაზღვრებით, არის მეორე რიცხვი. როდესაც ორივე რიცხვი ნულის ტოლია, მათი უდიდესი საერთო გამყოფი განუსაზღვრელია(undefined) (ეს შეიძლება იყოს ნებისმიერი თვითნებურად დიდი რიცხვი), მაგრამ მოსახერხებელია მისი განსაზღვრა როგორც ნული, ასევე $\gcd$-ის ასოციაციურობის შესანარჩუნებლად. რაც გვაძლევს მარტივ წესს: თუ რიცხვებიდან ერთი არის ნული, ყველაზე დიდი საერთო გამყოფი არის მეორე რიცხვი.


ქვემოთ განხილული ევკლიდური ალგორითმი საშუალებას იძლევა ვიპოვოთ, $a$ და $b$ ორი რიცხვის უდიდესი საერთო გამყოფი $O(\log \min(a, b))$-ში.

## ალგორითმი

თავდაპირველად, ევკლიდეს ალგორითმი ჩამოყალიბებული იყო შემდეგნაირად: გამოაკელით პატარა რიცხვი დიდს, სანამ ერთ-ერთი რიცხვი ნულის ტოლი იქნება. მართლაც, თუ $g$ ყოფს $a$-ს და $b$-ს, ის ასევე ყოფს $a-b$. მეორეს მხრივ, თუ $g$ ყოფს $a-b$-ს და $b$-ს, ის ასევე ყოფს $a = b + (a-b)$, რაც ნიშნავს, რომ $\{a, b\}$-ის საერთო გამყოფების სიმრავლეები და $\{b,a-b\}$ ემთხვევა.

გაითვალისწინეთ, რომ $a$ რჩება უფრო დიდ რიცხვად, სანამ $b$ არ გამოაკლდება მას $\left\lfloor\frac{a}{b}\right\rfloor$-ჯერ მაინც. ამიტომ, საქმეების დასაჩქარებლად, $a-b$ ჩანაცვლებულია $a-\left\lfloor\frac{a}{b}\right\rfloor b = a \bmod b$. შემდეგ ალგორითმი ჩამოყალიბებულია ძალიან მარტივი გზით:

$$\gcd(a, b) = \begin{cases}a,&\text{if }b = 0 \\ \gcd(b, a \bmod b),&\text{otherwise.}\end{cases}$$

## განხორციელება

```cpp
int gcd (int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd (b, a % b);
}
```

სამმაგი ოპერატორის დახმარებით C++-ში შეგვიძლია ჩავწეროთ როგორც ერთხაზოვანი.

```cpp
int gcd (int a, int b) {
    return b ? gcd (b, a % b) : a;
}
```

და ბოლოს, აქ არის არარეკურსიული განხორციელება:

```cpp
int gcd (int a, int b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

გაითვალისწინეთ, რომ C++17-დან, `gcd` დანერგილია როგორც [სტანდარტული ფუნქცია](https://en.cppreference.com/w/cpp/numeric/gcd) C++ -ში.

## დროის სირთულე (Time Complexity)

ალგორითმის მუშაობის დრო ფასდება ლამეს თეორემით, რომელიც ადგენს გასაოცარ კავშირს ევკლიდეს ალგორითმსა და ფიბონაჩის მიმდევრობას შორის:

თუ $a > b \geq 1$ და $b < F_n$ ზოგიერთი $n$-ისთვის, ევკლიდური ალგორითმი ასრულებს მაქსიმუმ $n-2$ რეკურსიულ გამოძახებას.

უფრო მეტიც, შესაძლებელია იმის ჩვენება, რომ ამ თეორემის ზედა ზღვარი ოპტიმალურია. როდესაც $a = F_n$ და $b = F_{n-1}$, $gcd(a, b)$ შეასრულებს ზუსტად $n-2$ რეკურსიულ ზარებს. სხვა სიტყვებით რომ ვთქვათ, თანმიმდევრული ფიბონაჩის რიცხვები ევკლიდეს ალგორითმის ყველაზე ცუდი შემთხვევის შეყვანაა.

იმის გათვალისწინებით, რომ ფიბონაჩის რიცხვები ექსპონენციალურად იზრდება, მივიღებთ, რომ ევკლიდეს ალგორითმი მუშაობს $O(\log \min(a,b))$-ში.

სირთულის შეფასების კიდევ ერთი გზაა შეამჩნიოთ, რომ $a \bmod b$ შემთხვევისთვის $a \geq b$ მინიმუმ $2$-ჯერ ნაკლებია $a$-ზე, ასე რომ, უფრო დიდი რიცხვი მცირდება მინიმუმ ნახევრჯერ ალგორითმის ყოველ გამეორებაზე.

## უმცირესი საერთო ჯერადი

უმცირესი საერთო ჯერადი (საყოველთაოდ აღინიშნა LCM) გამოთვლა შეიძლება შემცირდეს GCD-ის გამოანგარიშებამდე შემდეგი მარტივი ფორმულით:

$$\text{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)}$$

ამრიგად, LCM შეიძლება გამოითვალოს ევკლიდეს ალგორითმის გამოყენებით იგივე დროის სირთულით:

შესაძლო იმპლემენტაცია, რომელიც ჭკვიანურად თავიდან აიცილებს რიცხვების გადატვირთვას(Integer overflow), პირველად $a$-ის გაყოფით GCD-ზე, მოცემულია აქ:

```cpp
int lcm (int a, int b) {
    return a / gcd(a, b) * b;
}
```

## ორობითი (Binary) GCD

ორობითი GCD ალგორითმი არის ნორმალური ევკლიდური ალგორითმის ოპტიმიზაცია.

ნორმალური ალგორითმის ნელი ნაწილია მოდულის ოპერაციები. მოდულური ოპერაციები, თუმცა ჩვენ მათ ვხედავთ, როგორც $O(1)$, ბევრად უფრო ნელია, ვიდრე მარტივი ოპერაციები, როგორიცაა შეკრება, გამოკლება ან ბიტიური ოპერაციები.
ამიტომ ჯობია თავიდან აიცილოთ ისინი.


გამოდის, რომ თქვენ შეგიძლიათ შექმნათ სწრაფი GCD ალგორითმი, რომელიც თავიდან აიცილებს მოდულის ოპერაციებს.
იგი დაფუძნებულია რამდენიმე თვისებაზე:

 - თუ ორივე რიცხვი ლუწია, მაშინ შეგვიძლია გამოვყოთ ორივედან ორი და გამოვთვალოთ დარჩენილი რიცხვების GCD: $\gcd(2a, 2b) = 2 \gcd(a, b)$.
 - თუ რიცხვებიდან ერთი ლუწია, მეორე კი კენტი, მაშინ შეგვიძლია ლუწის კოეფიციენტი 2 წავშალოთ: $\gcd(2a, b) = \gcd(a, b)$ თუ $b$ კენტია. .
 - თუ ორივე რიცხვი კენტია, მაშინ მეორის ერთი რიცხვის გამოკლებით GCD არ შეიცვლება: $\gcd(a, b) = \gcd(b, a-b)$

მხოლოდ ამ თვისებების და GCC-ის ზოგიერთი სწრაფი ბიტიური ფუნქციის გამოყენებით, ჩვენ შეგვიძლია განვახორციელოთ სწრაფი ვერსია:

```cpp
int gcd(int a, int b) {
    if (!a || !b)
        return a | b;
    unsigned shift = __builtin_ctz(a | b);
    a >>= __builtin_ctz(a);
    do {
        b >>= __builtin_ctz(b);
        if (a > b)
            swap(a, b);
        b -= a;
    } while (b);
    return a << shift;
}
```
გაითვალისწინეთ, რომ ასეთი ოპტიმიზაცია ჩვეულებრივ არ არის საჭირო და პროგრამირების ენების უმეტესობას უკვე აქვს GCD ფუნქცია მათ სტანდარტულ ბიბლიოთეკებში.
Მაგალითად. C++17-ს აქვს ასეთი ფუნქცია `std::gcd` `numeric` სათაურში.

## პრაქტიკული პრობლემები
- [CSAcademy - Greatest Common Divisor](https://csacademy.com/contest/archive/task/gcd/)
