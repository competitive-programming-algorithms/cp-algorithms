# ფიბონაჩის რიცხვები

ფიბონაჩის თანმიმდევრობა განისაზღვრება შემდეგნაირად:

$$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$

მიმდევრობის პირველი ელემენტები ([OEIS A000045](http://oeis.org/A000045)) არის:

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$

## თვისებები

ფიბონაჩის რიცხვებს აქვთ ბევრი საინტერესო თვისება. აქ არის რამდენიმე მათგანი:

* კასინის ვინაობა:
  
$$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$

* "დამატების" წესი:
  
$$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$

* წინა იდენტობის გამოყენება $k = n$ საქმეზე, მივიღებთ:

$$F_{2n} = F_n (F_{n+1} + F_{n-1})$$

* აქედან ჩვენ შეგვიძლია დავამტკიცოთ ინდუქციით, რომ ნებისმიერი დადებითი მთელი რიცხვისთვის $k$, $F_{nk}$ არის $F_n$-ის ჯერადი.

* ინვერსიაც მართალია: თუ $F_m$ არის $F_n$-ის ჯერადი, მაშინ $m$ არის $n$-ის ჯერადი.

* GCD იდენტურობა:

$$GCD(F_m, F_n) = F_{GCD(m, n)}$$

* ფიბონაჩის რიცხვები ევკლიდეს ალგორითმისთვის ყველაზე ცუდი შესაძლო შენატანია (იხ. ლამის თეორემა [ევკლიდეს ალგორითმში](/algebra/euclid-algorithm))

## ფიბონაჩის კოდირება

ჩვენ შეგვიძლია გამოვიყენოთ თანმიმდევრობა დადებითი მთელი რიცხვების ორობითი კოდის სიტყვებში დასაშიფრად. ზეკენდორფის თეორემის მიხედვით, ნებისმიერი ბუნებრივი რიცხვი $n$ შეიძლება ცალსახად იყოს წარმოდგენილი ფიბონაჩის რიცხვების ჯამის სახით:

$$N = F_{k_1} + F_{k_2} + \ldots + F_{k_r}$$

ისეთი, რომ $k_1 \ge k_2 + 2,\ k_2 \ge k_3 + 2,\ \ldots,\ k_r \ge 2$ (ე.ი.: წარმოდგენა არ შეიძლება გამოიყენოს ზედიზედ ორი ფიბონაჩის რიცხვი).

აქედან გამომდინარეობს, რომ ნებისმიერი რიცხვი შეიძლება ცალსახად იყოს დაშიფრული ფიბონაჩის კოდირებაში.
და ჩვენ შეგვიძლია აღვწეროთ ეს წარმოდგენა ორობითი კოდებით $d_0 d_1 d_2 \dots d_s 1$, სადაც $d_i$ არის $1$, თუ $F_{i+2}$ გამოიყენება წარმოდგენაში.
კოდს დაემატება $1$ კოდის სიტყვის დასასრულის მითითებით.
გაითვალისწინეთ, რომ ეს არის ერთადერთი შემთხვევა, როდესაც ჩნდება ორი ზედიზედ 1-ბიტი.

$$\begin{eqnarray}
1 &=& 1 &=& F_2 &=& (11)_F \\
2 &=& 2 &=& F_3 &=& (011)_F \\
6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\
8 &=& 8 &=& F_6 &=& (000011)_F \\
9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\
19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F
\end{eqnarray}$$

$n$ მთელი რიცხვის კოდირება შეიძლება განხორციელდეს მარტივი ხარბ ალგორითმით:

1. გაიმეორეთ ფიბონაჩის რიცხვები უდიდესიდან უმცირესამდე, სანამ არ იპოვით $n$-ზე ნაკლები ან ტოლი.

2. დავუშვათ, რომ ეს რიცხვი იყო $F_i$. გამოვაკლოთ $F_i$ $n$-ს და დააყენოთ $1$ კოდის სიტყვის $i-2$ პოზიციაზე (ინდექსირება 0-დან მარცხნიდან ყველაზე მარჯვნივ).

3. გაიმეორეთ მანამ, სანამ ნარჩენები არ დარჩება.

4. დაამატეთ ბოლო $1$ კოდურ სიტყვას, რათა მიუთითოთ მისი დასასრული.

კოდის სიტყვის გაშიფვრისთვის ჯერ ამოიღეთ ბოლო $1$. შემდეგ, თუ დაყენებულია $i$-th ბიტი (ინდექსირება 0-დან მარცხნიდან ყველაზე მარჯვნივ), შეაჯამეთ $F_{i+2}$ რიცხვში.

## ფორმულები $n^{\text{th}}$ ფიბონაჩის ნომრისთვის { data-toc-label="ფორმულები <script type='math/tex'>n</script>-th ფიბონაჩის რიცხვისთვის" }

### დახურული გამოხატულება

არსებობს ფორმულა, რომელიც ცნობილია როგორც "ბინეტის ფორმულა", მიუხედავად იმისა, რომ ეს უკვე ცნობილი იყო Moivre-მ:

$$F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n - \left(\frac{1 - \sqrt{5}}{2}\right)^n}{\sqrt{5}}$$

ეს ფორმულა ადვილი დასამტკიცებელია ინდუქციით, მაგრამ მისი დადგენა შესაძლებელია ფუნქციების გენერირების კონცეფციის დახმარებით ან ფუნქციური განტოლების ამოხსნით.

თქვენ შეგიძლიათ დაუყოვნებლივ შეამჩნიოთ, რომ მეორე წევრის აბსოლუტური მნიშვნელობა ყოველთვის $1$-ზე ნაკლებია და ის ასევე მცირდება ძალიან სწრაფად (ექსპონენციალურად). აქედან გამომდინარე, მხოლოდ პირველი ტერმინის მნიშვნელობა არის "თითქმის" $F_n$. ეს შეიძლება დაიწეროს მკაცრად, როგორც:

$$F_n = \left[\frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n}{\sqrt{5}}\right]$$

სადაც კვადრატული ფრჩხილები აღნიშნავენ დამრგვალებას უახლოეს მთელ რიცხვამდე.

ვინაიდან ეს ორი ფორმულა მოითხოვს ძალიან მაღალ სიზუსტეს წილად რიცხვებთან მუშაობისას, ისინი ნაკლებად გამოიყენება პრაქტიკულ გამოთვლებში.

### ფიბონაჩი წრფივ დროში

$n$-th ფიბონაჩის რიცხვი მარტივად შეგიძლიათ იპოვოთ $O(n)$-ში, რიცხვების სათითაოდ გამოთვლებით $n$-მდე. თუმცა, არსებობს უფრო სწრაფი გზებიც, როგორც დავინახავთ.

ჩვენ შეგვიძლია დავიწყოთ განმეორებითი მიდგომით, ვისარგებლოთ $F_n = F_{n-1} + F_{n-2}$ ფორმულის გამოყენებით, შესაბამისად, ჩვენ უბრალოდ წინასწარ გამოვთვალოთ ეს მნიშვნელობები მასივში. საბაზისო შემთხვევების გათვალისწინებით $F_0$ და $F_1$.

```{.cpp file=fibonacci_linear}
int fib(int n) {
    int a = 0;
    int b = 1;
    for (int i = 0; i < n; i++) {
        int tmp = a + b;
        a = b;
        b = tmp;
    }
    return a;
}
```

ამ გზით, ჩვენ ვიღებთ წრფივ ამონახსნას, $O(n)$ დრო, რომელიც ვინახავთ ყველა მნიშვნელობას $n$-მდე თანმიმდევრობით.

### მატრიცის ფორმა

მარტივია შემდეგი ურთიერთობის დამტკიცება:

$$\begin{pmatrix} 1 & 1 \cr 1 & 0 \cr\end{pmatrix} ^ n = \begin{pmatrix} F_{n+1} & F_{n} \cr F_{n} & F_{n-1} \cr\end{pmatrix}$$

ამგვარად, იმისათვის, რომ ვიპოვოთ $F_n$ $O(log n)$ დროში, ჩვენ უნდა გავზარდოთ მატრიცა n-მდე. (იხ. [ორობითი ექსპონენტაცია](./binary-exp.md))

```{.cpp file=fibonacci_matrix}
struct matrix {
    long long mat[2][2];
    matrix friend operator *(const matrix &a, const matrix &b){
        matrix c;
        for (int i = 0; i < 2; i++) {
          for (int j = 0; j < 2; j++) {
              c.mat[i][j] = 0;
              for (int k = 0; k < 2; k++) {
                  c.mat[i][j] += a.mat[i][k] * b.mat[k][j];
              }
          }
        }
        return c;
    }
};

matrix matpow(matrix base, long long n) {
    matrix ans{ {
      {1, 0},
      {0, 1}
    } };
    while (n) {
        if(n&1)
            ans = ans*base;
        base = base*base;
        n >>= 1;
    }
    return ans;
}

long long fib(int n) {
    matrix base{ {
      {1, 1},
      {1, 0}
    } };
    return matpow(base, n).mat[0][1];
}
```
### სწრაფი გაორმაგების მეთოდი

ზემოაღნიშნული მატრიცის გამოხატვის გაფართოებით $n = 2\cdot k$-ისთვის

$$
\begin{pmatrix}
F_{2k+1} & F_{2k}\\
F_{2k} & F_{2k-1}
\end{pmatrix}
=
\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}^{2k}
=
\begin{pmatrix}
F_{k+1} & F_{k}\\
F_{k} & F_{k-1}
\end{pmatrix}
^2
$$

ჩვენ შეგვიძლია ვიპოვოთ ეს უფრო მარტივი განტოლებები:

$$ \begin{align}
F_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\
F_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\
\end{align}.$$

ამგვარად, ზემოთ ორი განტოლების გამოყენებით ფიბონაჩის რიცხვები მარტივად შეიძლება გამოითვალოს შემდეგი კოდით:

```{.cpp file=fibonacci_doubling}
pair<int, int> fib (int n) {
    if (n == 0)
        return {0, 1};

    auto p = fib(n >> 1);
    int c = p.first * (2 * p.second - p.first);
    int d = p.first * p.first + p.second * p.second;
    if (n & 1)
        return {d, c + d};
    else
        return {c, d};
}
```
ზემოაღნიშნული კოდი აბრუნებს $F_n$ და $F_{n+1}$ წყვილის სახით.

## პერიოდულობის modulo p

განვიხილოთ ფიბონაჩის მიმდევრობის მოდული $p$. ჩვენ დავამტკიცებთ, რომ თანმიმდევრობა პერიოდულია.

მოდით დავამტკიცოთ ეს წინააღმდეგობით. განვიხილოთ პირველი $p^2 + 1$ წყვილი ფიბონაჩის რიცხვები, რომლებიც მიღებულია $p$ მოდულით:

$$(F_0,\ F_1),\ (F_1,\ F_2),\ \ldots,\ (F_{p^2},\ F_{p^2 + 1})$$

შეიძლება იყოს მხოლოდ $p$ სხვადასხვა ნარჩენების მოდული $p$ და მაქსიმუმ $p^2$ სხვადასხვა ნარჩენების წყვილი, ასე რომ მათ შორის არის მინიმუმ ორი იდენტური წყვილი. ეს საკმარისია იმის დასამტკიცებლად, რომ მიმდევრობა პერიოდულია, რადგან ფიბონაჩის რიცხვი განისაზღვრება მხოლოდ მისი ორი წინამორბედით. ამრიგად, თუ ზედიზედ რიცხვების ორი წყვილი მეორდება, ეს ასევე ნიშნავს, რომ წყვილის შემდგომი რიცხვები იგივე გზით განმეორდება.

ახლა ჩვენ ვირჩევთ იდენტური ნაშთების ორ წყვილს მიმდევრობით ყველაზე პატარა ინდექსებით. მოდით, წყვილები იყოს $(F_a,\ F_{a + 1})$ და $(F_b,\ F_{b + 1})$. ჩვენ დავამტკიცებთ, რომ $a = 0$. თუ ეს მცდარი იყო, იქნებოდა ორი წინა წყვილი $(F_{a-1},\ F_a)$ და $(F_{b-1},\ F_b)$, რომლებიც, ფიბონაჩის რიცხვების თვისებით, ასევე იქნებოდა. იყოს თანაბარი. თუმცა, ეს ეწინააღმდეგება იმ ფაქტს, რომ ჩვენ ავირჩიეთ წყვილები უმცირესი ინდექსებით, რაც ავსებს მტკიცებულებას, რომ არ არსებობს წინასწარი პერიოდი (ანუ რიცხვები პერიოდულია $F_0$-დან დაწყებული).

## პარქტიკული პრობლემები

* [SPOJ - Euclid Algorithm Revisited](http://www.spoj.com/problems/MAIN74/)
* [SPOJ - Fibonacci Sum](http://www.spoj.com/problems/FIBOSUM/)
* [HackerRank - Is Fibo](https://www.hackerrank.com/challenges/is-fibo/problem)
* [Project Euler - Even Fibonacci numbers](https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem)
* [DMOJ - Fibonacci Sequence](https://dmoj.ca/problem/fibonacci)
* [DMOJ - Fibonacci Sequence (Harder)](https://dmoj.ca/problem/fibonacci2)
* [DMOJ UCLV - Numbered sequence of pencils](https://dmoj.uclv.edu.cu/problem/secnum)
* [DMOJ UCLV - Fibonacci 2D](https://dmoj.uclv.edu.cu/problem/fibonacci)
* [DMOJ UCLV - fibonacci calculation](https://dmoj.uclv.edu.cu/problem/fibonaccicalculatio)
* [LightOJ -  Number Sequence](https://lightoj.com/problem/number-sequence)
* [Codeforces - C. Fibonacci](https://codeforces.com/problemset/gymProblem/102644/C)
* [Codeforces - A. Hexadecimal's theorem](https://codeforces.com/problemset/problem/199/A)
* [Codeforces - B. Blackboard Fibonacci](https://codeforces.com/problemset/problem/217/B)
* [Codeforces - E. Fibonacci Number](https://codeforces.com/problemset/problem/193/E)