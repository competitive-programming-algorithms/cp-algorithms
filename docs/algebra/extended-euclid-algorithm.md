# გაფართოებული ევკლიდეს ალგორითმი

[ეუკლიდეს ალგორითმი](euclid-algorithm.md) ითვლის მხოლოდ უდიდეს საერთო გამყოფს (GCD) ორი მთელი რიცხვის $a$ და $b$, გაფართოებული ვერსია ასევე პოულობს გზას წარმოადგინოს GCD $a$ და $b$-ის თვალსაზრისით, ანუ კოეფიციენტები $x$ და $y$ ისთვისაც:

$$a \cdot x + b \cdot y = \gcd(a, b)$$

მნიშვნელოვანია აღინიშნოს, რომ  [Bézout's identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity)-ით ჩვენ ყოველთვის შეგვიძლია ვიპოვოთ ასეთი წარმოდგენა. მაგალითად, $\gcd(55, 80) = 5$, ამიტომ შეგვიძლია წარმოვადგინოთ $5$ როგორც წრფივი კომბინაცია ტერმინებით $55$ და $80$: $55 \cdot 3 + 80 \cdot (-2) = 5$

ამ პრობლემის უფრო ზოგადი ფორმა განხილულია სტატიაში [წრფივი დიოფანტინის განტოლებები](linear-diophantine-equation.md).
ის ამ ალგორითმზე იქნება აგებული.

## ალგორითმი

ჩვენ აღვნიშნავთ $a$-ის და $b$-ის GCD-ს $g$-ით ამ განყოფილებაში.

ორიგინალური ალგორითმის ცვლილებები ძალიან მარტივია.
თუ გავიხსენებთ ალგორითმს, დავინახავთ, რომ ალგორითმი მთავრდება $b = 0$ და $a = g$-ით.
ამ პარამეტრებისთვის ჩვენ მარტივად შეგვიძლია ვიპოვოთ კოეფიციენტები, კერძოდ, $g \cdot 1 + 0 \cdot 0 = g$.

ამ კოეფიციენტებიდან დაწყებული $(x, y) = (1, 0)$, ჩვენ შეგვიძლია უკან გადავიდეთ რეკურსიული ზარებით.
ყველაფერი რაც ჩვენ უნდა გავაკეთოთ არის იმის გარკვევა, თუ როგორ იცვლება $x$ და $y$ კოეფიციენტები $(a, b)$-დან $(b, a \bmod b)$-ზე გადასვლისას.

დავუშვათ, რომ ვიპოვეთ $(x_1, y_1)$ კოეფიციენტები $(b, a \bmod b)$-ისთვის:

$$b \cdot x_1 + (a \bmod b) \cdot y_1 = g$$

და ჩვენ გვინდა ვიპოვოთ $(x, y)$ წყვილი $(a, b)$-ისთვის:

$$ a \cdot x + b \cdot y = g$$

ჩვენ შეგვიძლია წარმოვადგინოთ $a \bmod b$ როგორც:

$$ a \bmod b = a - \left\lfloor \frac{a}{b} \right\rfloor \cdot b$$

ამ გამოხატვის ჩანაცვლება კოეფიციენტის განტოლებაში $(x_1, y_1)$ იძლევა:

$$ g = b \cdot x_1 + (a \bmod b) \cdot y_1 = b \cdot x_1 + \left(a - \left\lfloor \frac{a}{b} \right\rfloor \cdot b \right) \cdot y_1$$

და პირობების გადაწყობის შემდეგ:

$$g = a \cdot y_1 + b \cdot \left( x_1 - y_1 \cdot \left\lfloor \frac{a}{b} \right\rfloor \right)$$

ჩვენ ვიპოვეთ $x$ და $y$-ის მნიშვნელობები:

$$\begin{cases}
x = y_1 \\
y = x_1 - y_1 \cdot \left\lfloor \frac{a}{b} \right\rfloor
\end{cases} $$

## განხორციელება

```{.cpp file=extended_gcd}
int gcd(int a, int b, int& x, int& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int x1, y1;
    int d = gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - y1 * (a / b);
    return d;
}
```

ზემოთ მოყვანილი რეკურსიული ფუნქცია აბრუნებს GCD-ს და კოეფიციენტების მნიშვნელობებს `x` და `y` (რომლებიც გადაეცემა ფუნქციაზე მითითებით).

გაფართოებული ევკლიდური ალგორითმის ეს განხორციელება იძლევა სწორ შედეგებს უარყოფითი მთელი რიცხვებისთვისაც.
