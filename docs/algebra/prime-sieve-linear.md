# წრფივი საცერი

მოცემული რიცხვი $n$, იპოვეთ ყველა მარტივი რიცხვი სეგმენტში $[2;n]$.


ამოცანის გადაჭრის სტანდარტული გზაა [ერატოსთენეს საცრის](seve-of-eratosthenes.md) გამოყენება. ეს ალგორითმი ძალიან მარტივია, მაგრამ მას აქვს გაშვების დრო $O(n \log \log n)$.

მიუხედავად იმისა, რომ არსებობს ბევრი ცნობილი ალგორითმი ქვეწრფივი გაშვებით (ანუ $o(n)$), ქვემოთ აღწერილი ალგორითმი საინტერესოა თავისი სიმარტივით: ის არ არის უფრო რთული ვიდრე ერატოსთენეს კლასიკური საცერი.

გარდა ამისა, აქ მოცემული ალგორითმი ითვლის **ყველა რიცხვის ფაქტორიზაციას** სეგმენტში $[2; n]$, როგორც გვერდითი ეფექტი, და ეს შეიძლება სასარგებლო იყოს ბევრ პრაქტიკულ პროგრამაში.

მოცემული ალგორითმის სისუსტე არის ერატოსთენეს კლასიკურ საცერზე მეტი მეხსიერების გამოყენება: მას სჭირდება $n$ რიცხვების მასივი, ხოლო ერატოსთენეს კლასიკური საცრისთვის საკმარისია მეხსიერების $n$ ბიტი (რაც არის 32-ჯერ ნაკლები).

ამდენად, აზრი აქვს აღწერილი ალგორითმის გამოყენებას მხოლოდ $10^7$-ის რიგით რიცხვებისთვის და არა მეტი.

ალგორითმი პოლ პრიჩარდის დამსახურებაა. ეს არის ალგორითმის 3.3 ვარიანტი (Pritchard, 1987: იხილეთ მითითებები სტატიის ბოლოს).

## ალგორითმი

ჩვენი მიზანია გამოვთვალოთ **მინიმალური მარტივი კოეფიციენტი** $lp [i]$ ყოველი რიცხვისთვის $i$ სეგმენტში $[2; n]$.

გარდა ამისა, ჩვენ უნდა შევინახოთ ყველა ნაპოვნი მარტივი რიცხვის სია - მოდით დავარქვათ $pr []$.

$lp [i]$ მნიშვნელობების ინიციალიზაციას ვაკეთებთ ნულებით, რაც ნიშნავს, რომ ყველა რიცხვი მარტივია. ალგორითმის შესრულებისას ეს მასივი თანდათან შეივსება.

ახლა ჩვენ განვიხილავთ ციფრებს 2-დან $n$-მდე. ჩვენ გვაქვს ორი შემთხვევა ამჟამინდელი ნომრისთვის $i$:

- $lp[i] = 0$ - ეს ნიშნავს, რომ $i$ არის მარტივი, ანუ ჩვენ ვერ ვიპოვეთ მისთვის უფრო მცირე ფაქტორები.
  აქედან გამომდინარე, ჩვენ ვანიჭებთ $lp [i] = i$ და ვამატებთ $i$ სიის ბოლოს $pr[]$.

- $lp[i] \neq 0$ - ეს ნიშნავს, რომ $i$ არის კომპოზიტური და მისი მინიმალური პირველი ფაქტორი არის $lp [i]$.

ორივე შემთხვევაში ვაახლებთ $lp []$-ის მნიშვნელობებს იმ რიცხვებისთვის, რომლებიც იყოფა $i$-ზე. თუმცა, ჩვენი მიზანია ვისწავლოთ ამის გაკეთება, რათა დავაყენოთ $lp []$ მნიშვნელობა მაქსიმუმ ერთხელ ყოველ რიცხვზე. ჩვენ შეგვიძლია ამის გაკეთება შემდეგნაირად:

განვიხილოთ რიცხვები $x_j = i \cdot p_j$, სადაც $p_j$ არის ყველა მარტივი რიცხვი $lp [i]$-ზე ნაკლები ან ტოლი (ამიტომ უნდა შევინახოთ ყველა მარტივი რიცხვის სია).

ჩვენ დავაყენებთ ახალ მნიშვნელობას $lp [x_j] = p_j$ ამ ფორმის ყველა რიცხვისთვის.

ამ ალგორითმის სისწორის მტკიცებულება და მისი გაშვების დრო შეგიძლიათ იხილოთ განხორციელების შემდეგ.

## განხორციელება

```cpp
const int N = 10000000;
vector<int> lp(N+1);
vector<int> pr;
 
for (int i=2; i <= N; ++i) {
	if (lp[i] == 0) {
		lp[i] = i;
		pr.push_back(i);
	}
	for (int j = 0; i * pr[j] <= N; ++j) {
		lp[i * pr[j]] = pr[j];
		if (pr[j] == lp[i]) {
			break;
		}
	}
}
```

## სისწორის მტკიცებულება

ჩვენ უნდა დავამტკიცოთ, რომ ალგორითმი სწორად ადგენს $lp []$ მნიშვნელობას და რომ ყველა მნიშვნელობა დაყენდება ზუსტად ერთხელ. ამრიგად, ალგორითმს ექნება წრფივი გაშვების დრო, რადგან ალგორითმის ყველა დარჩენილი მოქმედება, ცხადია, მუშაობს $O (n)$-ზე.

გაითვალისწინეთ, რომ თითოეულ რიცხვს $i$ აქვს ზუსტად ერთი წარმოდგენა ფორმაში:

$$i = lp [i] \cdot x,$$

სადაც $lp [i]$ არის $i$-ის მინიმალური მარტივი კოეფიციენტი, ხოლო რიცხვს $x$ არ აქვს $lp [i]$-ზე ნაკლები მარტივი ფაქტორები, ე.ი.

$$lp [i] \le lp [x].$$

ახლა, მოდით შევადაროთ ეს ჩვენი ალგორითმის მოქმედებებს: ფაქტობრივად, ყოველ $x$-ზე, რომელიც გადის ყველა მარტივ რიცხვზე, ის შეიძლება გავამრავლოთ, ანუ ყველა მარტივი რიცხვი $lp [x]$-მდე ჩათვლით, რათა მივიღოთ. ნომრები ზემოთ მოცემულ ფორმაში.

მაშასადამე, ალგორითმი ზუსტად ერთხელ გაივლის ყველა კომპოზიტურ რიცხვს და იქ დააყენებს სწორ მნიშვნელობებს $lp []$. Q.E.D.

## გაშვების დრო და მეხსიერება

მიუხედავად იმისა, რომ $O(n)$-ის გაშვების დრო უკეთესია ვიდრე $O(n \log \log n)$ ერატოსთენეს კლასიკური საცრის, მათ შორის განსხვავება არც ისე დიდია.
პრაქტიკაში წრფივი საცერი მუშაობს დაახლოებით ისეთივე სწრაფად, როგორც ერატოსთენეს საცრის ტიპიური განხორციელება.

ერათოსთენეს საცრის ოპტიმიზებულ ვერსიებთან შედარებით, მაგ. სეგმენტირებული sieve, ეს არის ბევრად უფრო ნელი.

ამ ალგორითმის მეხსიერების მოთხოვნების გათვალისწინებით - მასივი $lp []$ $n$ სიგრძით და $pr []$ სიგრძით $\frac n {\ln n}$, ეს ალგორითმი, როგორც ჩანს, უარესია. კლასიკური საცერი ყოველმხრივ.

თუმცა, მისი გამოსყიდვის ხარისხი არის ის, რომ ეს ალგორითმი ითვლის $lp []$ მასივს, რომელიც საშუალებას გვაძლევს ვიპოვოთ ნებისმიერი რიცხვის ფაქტორიზაცია სეგმენტში $[2; n]$ ამ ფაქტორიზაციის ზომის რიგის დროში. უფრო მეტიც, მხოლოდ ერთი დამატებითი მასივის გამოყენება საშუალებას მოგვცემს თავიდან ავიცილოთ დაყოფა ფაქტორიზაციის ძიებისას.

ყველა რიცხვის ფაქტორიზაციის ცოდნა ძალიან სასარგებლოა ზოგიერთი ამოცანისთვის და ეს ალგორითმი ერთ-ერთია იმ მცირერიცხოვანთაგან, რომელიც საშუალებას გაძლევთ იპოვოთ ისინი წრფივ დროში.

## ცნობები

- პოლ პრიჩარდი,  **Linear Prime-Number Sieves: a Family Tree**, კომპიუტერული პროგრამირების მეცნიერება, ტ. 9 (1987), გვ.17-35.
