# პირველობის ტესტები

ეს სტატია აღწერს მრავალ ალგორითმს იმის დასადგენად, არის თუ არა რიცხვი მარტივი.

## Trial division

განმარტებით, პირველ რიცხვს არ აქვს გამყოფები $1$-ისა და საკუთარი თავის გარდა.
კომპოზიტურ რიცხვს აქვს მინიმუმ ერთი დამატებითი გამყოფი, მოდით დავარქვათ $d$.
ბუნებრივია, $\frac{n}{d}$ ასევე არის $n$-ის გამყოფი.
ადვილი მისახვედრია, რომ $d \le \sqrt{n}$ ან $\frac{n}{d} \le \sqrt{n}$, ამიტომ ერთ-ერთი გამყოფი $d$ და $\frac{n {d}$ არის $\le \sqrt{n}$.
ჩვენ შეგვიძლია გამოვიყენოთ ეს ინფორმაცია პირველობის შესამოწმებლად.

ჩვენ ვცდილობთ ვიპოვოთ არატრივიალური გამყოფი, შემოწმებით, არის თუ არა რომელიმე რიცხვი $2$-დან $\sqrt{n}$-ის გამყოფი $n$-ის.
თუ ეს არის გამყოფი, მაშინ $n$ ნამდვილად არ არის მარტივი, წინააღმდეგ შემთხვევაში ასეა.

```cpp
bool isPrime(int x) {
    for (int d = 2; d * d <= x; d++) {
        if (x % d == 0)
            return false;
    }
    return x >= 2;
}
```

ეს არის ძირითადი შემოწმების უმარტივესი ფორმა.
ამ ფუნქციის საკმაოდ ოპტიმიზაცია შეგიძლიათ, მაგალითად მარყუჟში მხოლოდ ყველა კენტი რიცხვის შემოწმებით, რადგან ერთადერთი ლუწი მარტივი რიცხვი არის 2.
მრავალი ასეთი ოპტიმიზაცია აღწერილია სტატიაში [მთელი რიცხვების ფაქტორიზაციის](factorization.md) შესახებ.

## ფერმატის პირველობის ტესტი

ეს ალბათობის ტესტია.

ფერმას პატარა თეორემა (იხ. აგრეთვე [Euler's totient function](phi-function.md)) ამბობს, რომ $p$ მარტივი რიცხვისთვის და $a$ თანაპირველი მთელი რიცხვისთვის შემდეგი განტოლება მოქმედებს:

$$a^{p-1} \equiv 1 \bmod p$$

ზოგადად, ეს თეორემა არ მოქმედებს შედგენილ რიცხვებზე.

ეს შეიძლება გამოყენებულ იქნას პირველობის ტესტის შესაქმნელად.
ჩვენ ვირჩევთ მთელ რიცხვს $2 \le a \le p - 2$ და ვამოწმებთ, მოქმედებს თუ არა განტოლება.
თუ არ იჭერს, ე.ი. $a^{p-1} \not\equiv 1 \bmod p$, ვიცით, რომ $p$ არ შეიძლება იყოს მარტივი რიცხვი.
ამ შემთხვევაში ჩვენ $a$-ს ვეძახით *Fermat witness* $p$-ის კომპოზიტურობისთვის.

თუმცა ასევე შესაძლებელია, რომ განტოლება შედგენილ რიცხვს ეხებოდეს.
ასე რომ, თუ განტოლება ძალაშია, ჩვენ არ გვაქვს მტკიცებულება პირველობაზე.
ჩვენ მხოლოდ შეგვიძლია ვთქვათ, რომ $p$ არის *probably prime*.
თუ აღმოჩნდება, რომ რიცხვი რეალურად არის შედგენილი, ჩვენ ვუწოდებთ $a$-ის ბაზას *Fermat liar*.

$a$-ის ყველა შესაძლო საფუძვლის ტესტის გაშვებით, ჩვენ შეგვიძლია რეალურად დავამტკიცოთ, რომ რიცხვი მარტივია.
თუმცა ეს პრაქტიკაში არ კეთდება, რადგან ეს ბევრად მეტი ძალისხმევაა, ვიდრე უბრალოდ *საცდელი დაყოფა*.
ამის ნაცვლად ტესტი რამდენჯერმე განმეორდება შემთხვევითი არჩევანით $a$-ად.
თუ ჩვენ ვერ ვიპოვით შედგენილობის მოწმეს, ძალიან სავარაუდოა, რომ რიცხვი სინამდვილეში მარტივია.

```cpp
bool probablyPrimeFermat(int n, int iter=5) {
    if (n < 4)
        return n == 2 || n == 3;

    for (int i = 0; i < iter; i++) {
        int a = 2 + rand() % (n - 3);
        if (binpower(a, n - 1, n) != 1)
            return false;
    }
    return true;
}
```

ჩვენ ვიყენებთ [Binary Exponentiation](binary-exp.md) $a^{p-1}$ სიმძლავრის ეფექტურად გამოსათვლელად.

თუმცა არის ერთი ცუდი ამბავი:
არსებობს რამდენიმე შედგენილი რიცხვი, სადაც $a^{n-1} \equiv 1 \bmod n$ მოქმედებს ყველა $a$ coprime-დან $n$-მდე, მაგალითად რიცხვისთვის $561 = 3 \cdot 11 \cdot 17$.
ასეთ რიცხვებს *კარმიხელის რიცხვებს* უწოდებენ.
Fermat primality ტესტს შეუძლია ამ რიცხვების იდენტიფიცირება მხოლოდ იმ შემთხვევაში, თუ ჩვენ გვაქვს უზარმაზარი იღბალი და ავირჩევთ $a$ საფუძველს $\gcd(a, n) \ne 1$-ით.

Fermat ტესტი ჯერ კიდევ გამოიყენება პრაქტიკაში, რადგან ის ძალიან სწრაფია და კარმაიკლის რიცხვები ძალიან იშვიათია.
Მაგალითად. არსებობს მხოლოდ 646 ასეთი რიცხვი $10^9$-ზე დაბალი.

## მილერ-რაბინის პირველობის ტესტი

მილერ-რაბინის ტესტი ავრცელებს იდეებს ფერმას ტესტიდან.

კენტი რიცხვისთვის $n$, $n-1$ არის ლუწი და შეგვიძლია გამოვყოთ 2-ის ყველა ძალა.
ჩვენ შეგვიძლია დავწეროთ:

$$n - 1 = 2^s \cdot d,~\text{with}~d~\text{odd}.$$

ეს გვაძლევს ფერმას პატარა თეორემის განტოლების ფაქტორიზირებას:

$$\begin{array}{rl}
a^{n-1} \equiv 1 \bmod n &\Longleftrightarrow a^{2^s d} - 1 \equiv 0 \bmod n \\\\
&\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \equiv 0 \bmod n \\\\
&\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \equiv 0 \bmod n \\\\
&\quad\vdots \\\\
&\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \cdots (a^{d} + 1) (a^{d} - 1) \equiv 0 \bmod n \\\\
\end{array}$$

თუ $n$ არის მარტივი, მაშინ $n$-მა უნდა გაყოს ამ ფაქტორებიდან ერთ-ერთი.
და მილერ-რაბინის პირველობის ტესტში ჩვენ ვამოწმებთ ზუსტად იმ დებულებას, რომელიც უფრო მკაცრი ვერსიაა ფერმას ტესტის განცხადების.
$2 \le a \le n-2$ ფუძისთვის ვამოწმებთ თუ არა

$$a^d \equiv 1 \bmod n$$

ფლობს ან

$$a^{2^r d} \equiv -1 \bmod n$$

ეტევა დაახლოებით $0 \le r \le s - 1$.

თუ ჩვენ ვიპოვნეთ $a$-ის ბაზა, რომელიც არ აკმაყოფილებს ზემოთ ჩამოთვლილთაგან არცერთ თანასწორობას, მაშინ ვიპოვნეთ *witness* $n$-ის კომპოზიტურობისთვის.
ამ შემთხვევაში ჩვენ დავამტკიცეთ, რომ $n$ არ არის მარტივი რიცხვი.

ფერმას ტესტის მსგავსად, ასევე შესაძლებელია, რომ განტოლებათა სიმრავლე დაკმაყოფილდეს კომპოზიტური რიცხვისთვის.
ამ შემთხვევაში $a$ ფუძეს ეწოდება *ძლიერი მატყუარა*.
თუ $a$ ფუძე აკმაყოფილებს განტოლებებს (ერთ-ერთ მათგანს), $n$ არის მხოლოდ *ძლიერი სავარაუდო პირველი*.
თუმცა, არ არსებობს ისეთი რიცხვები, როგორიც კარმაიკლის რიცხვებია, სადაც ყველა არატრივიალური საფუძველი დევს.
სინამდვილეში, შესაძლებელია იმის ჩვენება, რომ ბაზებიდან მაქსიმუმ $\frac{1}{4}$ შეიძლება იყოს ძლიერი მატყუარა.
თუ $n$ კომპოზიტურია, ჩვენ გვაქვს $\ge 75\%$ ალბათობა, რომ შემთხვევითი ბაზა გვეტყვის, რომ ის კომპოზიტურია.
მრავალჯერადი გამეორებით, სხვადასხვა შემთხვევითი ბაზის არჩევით, ძალიან დიდი ალბათობით შეგვიძლია ვთქვათ, რიცხვი ნამდვილად მარტივია თუ შედგენილი.

აქ არის განხორციელება 64 ბიტიანი მთელი რიცხვისთვის.

```cpp
using u64 = uint64_t;
using u128 = __uint128_t;

u64 binpower(u64 base, u64 e, u64 mod) {
    u64 result = 1;
    base %= mod;
    while (e) {
        if (e & 1)
            result = (u128)result * base % mod;
        base = (u128)base * base % mod;
        e >>= 1;
    }
    return result;
}

bool check_composite(u64 n, u64 a, u64 d, int s) {
    u64 x = binpower(a, d, n);
    if (x == 1 || x == n - 1)
        return false;
    for (int r = 1; r < s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1)
            return false;
    }
    return true;
};

bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.
    if (n < 4)
        return n == 2 || n == 3;

    int s = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        s++;
    }

    for (int i = 0; i < iter; i++) {
        int a = 2 + rand() % (n - 3);
        if (check_composite(n, a, d, s))
            return false;
    }
    return true;
}
```

მილერ-რაბინის ტესტის დაწყებამდე შეგიძლიათ დამატებით შეამოწმოთ, არის თუ არა პირველი რამდენიმე მარტივი რიცხვიდან ერთ-ერთი გამყოფი.
ამან შეიძლება მნიშვნელოვნად დააჩქაროს ტესტირება, რადგან შედგენილ რიცხვთა უმეტესობას აქვს ძალიან მცირე მარტივი გამყოფები.
Მაგალითად. $88\%$ ყველა რიცხვს აქვს $100$-ზე ნაკლები ძირითადი ფაქტორი.

### დეტერმინისტული ვერსია

მილერმა აჩვენა, რომ შესაძლებელია ალგორითმის განმსაზღვრელი მხოლოდ $\le O((\ln n)^2)$-ის ყველა ბაზის შემოწმებით.
მოგვიანებით ბახმა მისცა კონკრეტული ზღვარი, საჭიროა მხოლოდ $a \le 2 \ln(n)^2$ ყველა ფუძის შემოწმება.

ეს ჯერ კიდევ საკმაოდ დიდი რაოდენობის ბაზებია.
ასე რომ, ადამიანებმა საკმაოდ დიდი გამოთვლითი ძალა დახარჯეს ქვედა საზღვრების პოვნაში.
გამოდის, რომ 32 ბიტიანი მთელი რიცხვის შესამოწმებლად საჭიროა მხოლოდ პირველი 4 ძირითადი ბაზის შემოწმება: 2, 3, 5 და 7.
ყველაზე პატარა კომპოზიტური რიცხვი, რომელიც ვერ გაივლის ამ ტესტს, არის $3,215,031,751 = 151 \cdot 751 \cdot 28351$.
ხოლო 64 ბიტიანი მთელი რიცხვის შესამოწმებლად საკმარისია შეამოწმოთ პირველი 12 ძირითადი ბაზა: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 და 37.

ეს იწვევს შემდეგ განმსაზღვრელ განხორციელებას:

```cpp
bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.
    if (n < 2)
        return false;

    int r = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }

    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)
            return true;
        if (check_composite(n, a, d, r))
            return false;
    }
    return true;
}
```

ასევე შესაძლებელია შემოწმების გაკეთება მხოლოდ 7 ბაზით: 2, 325, 9375, 28178, 450775, 9780504 და 1795265022.
თუმცა, რადგან ეს რიცხვები (გარდა 2-ისა) არ არის მარტივი, თქვენ დამატებით უნდა შეამოწმოთ, არის თუ არა თქვენს მიერ შემოწმებული რიცხვი ამ ფუძეების ნებისმიერ მარტივ გამყოფთან: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837.

## სავარჯიშო

- [SPOJ - Prime or Not](https://www.spoj.com/problems/PON/)
- [Project euler - Investigating a Prime Pattern](https://projecteuler.net/problem=146)
