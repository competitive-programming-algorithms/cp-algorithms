# ერატოსთენეს საცერი

ერატოსთენეს საცერი არის ალგორითმი $[1;n]$ სეგმენტში ყველა მარტივი რიცხვის საპოვნელად $O(n \log \log n)$ ოპერაციების გამოყენებით.

ალგორითმი ძალიან მარტივია:
დასაწყისში ჩვენ ვწერთ ყველა რიცხვს 2-დან $n$-მდე.
ჩვენ აღვნიშნავთ 2-ის ყველა სწორ ჯერადს (რადგან 2 არის უმცირესი მარტივი რიცხვი), როგორც შედგენილი.
$x$ რიცხვის სწორი ჯერადი არის რიცხვი $x$-ზე მეტი და იყოფა $x$-ზე.
შემდეგ ვპოულობთ შემდეგ რიცხვს, რომელიც არ არის მონიშნული, როგორც შედგენილი, ამ შემთხვევაში ეს არის 3.
რაც ნიშნავს, რომ 3 არის მარტივი და ჩვენ აღვნიშნავთ 3-ის ყველა სათანადო ჯერადს, როგორც კომპოზიტურს.
შემდეგი არამონიშნული რიცხვია 5, რომელიც არის შემდეგი მარტივი რიცხვი და ჩვენ აღვნიშნავთ მის ყველა სათანადო ჯერადს.
და ჩვენ ვაგრძელებთ ამ პროცედურას მანამ, სანამ არ დავამუშავებთ ყველა რიცხვს მწკრივში.

შემდეგ სურათზე შეგიძლიათ იხილოთ ალგორითმის ვიზუალიზაცია ყველა მარტივი რიცხვის გამოთვლისთვის დიაპაზონში $[1; 16]$. ჩანს, რომ ხშირად ჩვენ არაერთხელ აღვნიშნავთ რიცხვებს კომპოზიტურად.

<center>![Sieve of Eratosthenes](sieve_eratosthenes.png)</center>

იდეა ასეთია:
რიცხვი მარტივია, თუ არც ერთი პატარა მარტივი რიცხვი არ ყოფს მას.
რადგან ჩვენ ვიმეორებთ მარტივ რიცხვებს თანმიმდევრობით, ჩვენ უკვე აღვნიშნეთ ყველა რიცხვი, რომლებიც იყოფა სულ მცირე ერთ მარტივ რიცხვზე, როგორც იყოფა.აქედან გამომდინარე, თუ უჯრედს მივაღწევთ და ის არ არის მონიშნული, მაშინ ის არ იყოფა არცერთ უფრო მცირე მარტივ რიცხვზე და ამიტომ უნდა იყოს მარტივი.

## განხორციელება

```cpp
int n;
vector<bool> is_prime(n+1, true);
is_prime[0] = is_prime[1] = false;
for (int i = 2; i <= n; i++) {
    if (is_prime[i] && (long long)i * i <= n) {
        for (int j = i * i; j <= n; j += i)
            is_prime[j] = false;
    }
}
```

ეს კოდი პირველ რიგში აღნიშნავს ყველა რიცხვს, გარდა ნულისა და ერთისა, როგორც პოტენციური მარტივი რიცხვები, შემდეგ კი იწყება კომპოზიციური რიცხვების გარჩევის პროცესი. ამისათვის ის იმეორებს ყველა რიცხვს $2$-დან $n$-მდე.
თუ ამჟამინდელი რიცხვი $i$ არის მარტივი რიცხვი, ის აღნიშნავს ყველა რიცხვს, რომლებიც $i$-ის ჯერადი რიცხვებია, როგორც შედგენილი რიცხვები, დაწყებული $i^2$-დან.
ეს უკვე ოპტიმიზაციაა მისი განხორციელების გულუბრყვილო ხერხზე და დაშვებულია, რადგან ყველა პატარა რიცხვს, რომელიც არის $i$-ის ჯერადი საჭირო, ასევე აქვს მთავარი ფაქტორი, რომელიც $i$-ზე ნაკლებია, ამიტომ ყველა მათგანი ადრე იყო გაცრილი.
ვინაიდან $i^2$-ს შეუძლია ადვილად გადაფაროს ტიპი `int`, დამატებითი დადასტურება კეთდება ტიპი `long long` მეორე ჩადგმულ ციკლამდე.

ასეთი განხორციელების გამოყენებით ალგორითმი მოიხმარს მეხსიერების $O(n)$ (ცხადია) და ასრულებს $O(n \log \log n)$ (იხილეთ შემდეგი განყოფილება).

## ასიმპტომური ანალიზი

მარტივია $O(n \log n)$-ის გაშვების დროის დამტკიცება, მარტივი რიცხვების განაწილების შესახებ არაფრის ცოდნის გარეშე - `is_prime` შემოწმების უგულებელყოფით, შიდა ციკლი გადის (მაქსიმუმ) $n/i$-ჯერ $i-ზე. = 2, 3, 4, \dots$, რაც იწვევს ოპერაციების საერთო რაოდენობას შიდა მარყუჟში ჰარმონიულ ჯამს, როგორიცაა $n(1/2 + 1/3 + 1/4 + \cdots)$, რომელიც შემოსაზღვრულია. $O(n \log n)$-ის მიერ.

მოდით დავამტკიცოთ, რომ ალგორითმის მუშაობის დრო არის $O(n \log \log n)$.
ალგორითმი შეასრულებს $\frac{n}{p}$ ოპერაციებს შიდა მარყუჟის თითოეული ძირითადი $p \le n$-ისთვის.
აქედან გამომდინარე, ჩვენ უნდა შევაფასოთ შემდეგი გამონათქვამი:

$$\sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac n p = n \cdot \sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac 1 p.$$

გავიხსენოთ ორი ცნობილი ფაქტი.

  - $n$-ზე ნაკლები ან ტოლი მარტივი რიცხვების რაოდენობა არის დაახლოებით $\frac n {\ln n}$.
  - $k$-th მარტივი რიცხვი დაახლოებით უდრის $k \ln k$-ს (ეს პირდაპირ გამომდინარეობს წინა ფაქტიდან).
ამრიგად, ჩვენ შეგვიძლია ჩამოვწეროთ თანხა შემდეგნაირად:

$$\sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac 1 p \approx \frac 1 2 + \sum_{k = 2}^{\frac n {\ln n}} \frac 1 {k \ln k}.$$

აქ ჩვენ ამოვიღეთ პირველი მარტივი რიცხვი 2 ჯამიდან, რადგან $k = 1$ მიახლოებით $k \ln k$ არის $0$ და იწვევს ნულზე გაყოფას.

ახლა, მოდით შევაფასოთ ეს ჯამი იგივე ფუნქციის ინტეგრალის გამოყენებით $k$-ზე $2$-დან $\frac n {\ln n}$-მდე (შეგვიძლია ასეთი მიახლოება, რადგან, ფაქტობრივად, ჯამი დაკავშირებულია ინტეგრალთან, როგორც მისი მიახლოება მართკუთხედის მეთოდით):

$$\sum_{k = 2}^{\frac n {\ln n}} \frac 1 {k \ln k} \approx \int_2^{\frac n {\ln n}} \frac 1 {k \ln k} dk.$$

ინტეგრანდისთვის ანტიწარმოებული არის $\ln \ln k$. ჩანაცვლების გამოყენებით და ქვედა რიგის პირობების ამოღებით, ჩვენ მივიღებთ შედეგს:

$$\int_2^{\frac n {\ln n}} \frac 1 {k \ln k} dk = \ln \ln \frac n {\ln n} - \ln \ln 2 = \ln(\ln n - \ln \ln n) - \ln \ln 2 \approx \ln \ln n.$$

ახლა, დავუბრუნდეთ თავდაპირველ თანხას, მივიღებთ მის სავარაუდო შეფასებას:

$$\sum_{\substack{p \le n, \\\ p\ is\ prime}} \frac n p \approx n \ln \ln n + o(n).$$

თქვენ შეგიძლიათ იპოვოთ უფრო მკაცრი მტკიცებულება (რომელიც იძლევა უფრო ზუსტ შეფასებას, რომელიც ზუსტია მუდმივი მულტიპლიკატორების ფარგლებში) ჰარდი და რაიტის ავტორის წიგნში "შესავალი რიცხვების თეორიაში" (გვ. 349).

## ერატოსთენეს საცრის სხვადასხვა ოპტიმიზაცია

ალგორითმის ყველაზე დიდი სისუსტე ის არის, რომ ის მრავალჯერ „დადის“ მეხსიერების გასწვრივ, მხოლოდ ცალკეული ელემენტებით მანიპულირებს.
ეს არ არის ქეშირებისთვის მეგობრული.
და ამის გამო, მუდმივი, რომელიც დამალულია $O(n \log \log n)$-ში შედარებით დიდია.

გარდა ამისა, მოხმარებული მეხსიერება არის შეფერხება დიდი $n$-ისთვის.

ქვემოთ წარმოდგენილი მეთოდები საშუალებას გვაძლევს შევამციროთ შესრულებული ოპერაციების რაოდენობა, ასევე შესამჩნევად შევამოკლოთ მოხმარებული მეხსიერება.

### გაცრა ფესვებამდე

ცხადია, $n$-მდე ყველა მარტივი რიცხვის საპოვნელად საკმარისი იქნება გაცრილი მხოლოდ მარტივი რიცხვებით, რომლებიც არ აღემატება $n$-ის ფესვს.

```cpp
int n;
vector<bool> is_prime(n+1, true);
is_prime[0] = is_prime[1] = false;
for (int i = 2; i * i <= n; i++) {
    if (is_prime[i]) {
        for (int j = i * i; j <= n; j += i)
            is_prime[j] = false;
    }
}
```

ასეთი ოპტიმიზაცია გავლენას არ ახდენს სირთულეზე (ნამდვილად, ზემოთ წარმოდგენილი მტკიცებულების გამეორებით მივიღებთ შეფასებას $n \ln \ln \sqrt n + o(n)$, რომელიც ასიმპტომურად იგივეა ლოგარითმების თვისებების მიხედვით. ), თუმცა ოპერაციების რაოდენობა საგრძნობლად შემცირდება.

### გაცრა მხოლოდ კენტი რიცხვებით

ვინაიდან ყველა ლუწი რიცხვი (გარდა $2$-ისა) კომპოზიტურია, ჩვენ შეგვიძლია საერთოდ შევწყვიტოთ ლუწი რიცხვების შემოწმება. ამის ნაცვლად, ჩვენ უნდა ვიმოქმედოთ მხოლოდ კენტი რიცხვებით.

პირველ რიგში, ეს საშუალებას მოგვცემს გავანახევროთ საჭირო მეხსიერება. მეორე, ეს შეამცირებს ალგორითმის მიერ შესრულებული ოპერაციების რაოდენობას დაახლოებით ნახევარში.


### მეხსიერების მოხმარება და ოპერაციების სიჩქარე

უნდა აღინიშნოს, რომ ერატოსთენეს საცრის ეს ორი იმპლემენტაცია იყენებს მეხსიერების $n$ ბიტს მონაცემთა სტრუქტურის `vector<bool>` გამოყენებით.
`vector<bool>` არ არის ჩვეულებრივი კონტეინერი, რომელიც ინახავს `bool`-ის სერიას (როგორც უმეტეს კომპიუტერულ არქიტექტურაში, `bool` იკავებს მეხსიერების ერთ ბაიტს).
ეს არის `vector<T>` მეხსიერების ოპტიმიზაციის სპეციალიზაცია, რომელიც მოიხმარს მხოლოდ $\frac{N}{8}$ მეხსიერების ბაიტებს.

თანამედროვე პროცესორების არქიტექტურა ბევრად უფრო ეფექტურად მუშაობს ბაიტებთან, ვიდრე ბიტებთან, რადგან მათ ჩვეულებრივ არ შეუძლიათ უშუალოდ ბიტებზე წვდომა.
ასე რომ, `vector<bool>` ქვეშ ინახავს ბიტებს დიდ უწყვეტ მეხსიერებაში, წვდება მეხსიერებას რამდენიმე ბაიტის ბლოკად და ამოაქვს/დააყენებს ბიტებს ბიტის ოპერაციებით, როგორიცაა ბიტის დაფარვა და ბიტის შეცვლა.

ამის გამო არის გარკვეული ზედნადები, როდესაც კითხულობთ ან წერთ ბიტებს `vector<bool>`, და საკმაოდ ხშირად იყენებთ `vector<char>`-ს (რომელიც იყენებს 1 ბაიტს თითოეული ჩანაწერისთვის, შესაბამისად მეხსიერების 8-ჯერ მეტი) უფრო სწრაფია.

თუმცა, ერატოსთენეს საცრის მარტივი განხორციელებისთვის `vector<bool>` უფრო სწრაფია.
თქვენ შეზღუდული ხართ იმით, თუ რამდენად სწრაფად შეგიძლიათ ჩატვირთოთ მონაცემები ქეშში და, შესაბამისად, ნაკლები მეხსიერების გამოყენება დიდ უპირატესობას იძლევა.
საორიენტაციო ნიშანი (benchmark) ([ბმული](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) აჩვენებს, რომ `vector<bool>`-ის გამოყენება 1,4-დან 1,7-ჯერ უფრო სწრაფია, ვიდრე `vector<char>`-ის გამოყენება. .

იგივე მოსაზრებები ვრცელდება `bitset`-ზე.
ის ასევე არის ბიტების შესანახად ეფექტური გზა, მსგავსი `vector<bool>`, ამიტომ მას სჭირდება მხოლოდ $\frac{N}{8}$ ბაიტი მეხსიერება, მაგრამ ოდნავ ნელია ელემენტებზე წვდომისას.

ზემოთ მოცემულ ეტალონში `bitset` ოდნავ უარესად მუშაობს, ვიდრე `vector<bool>`.
კიდევ ერთი ნაკლი `bitset` არის ის, რომ თქვენ უნდა იცოდეთ ზომა კომპილაციის დროს.

### სეგმენტირებული საცერი

ოპტიმიზაციიდან გამომდინარეობს, რომ არ არის საჭირო მთელი მასივის `is_prime[1...n]` მუდმივად შენარჩუნება.
საცრისთვის საკმარისია უბრალოდ შევინარჩუნოთ მარტივი რიცხვები $n$-ის ფესვამდე, ანუ `prime[1... sqrt(n)]`, დაყოთ სრული დიაპაზონი ბლოკებად და თითოეული ბლოკი ცალკე გაცრათ.

მოდით $s$ იყოს მუდმივი, რომელიც განსაზღვრავს ბლოკის ზომას, მაშინ გვაქვს $\lceil {\frac n s} \rceil$ ბლოკები საერთოდ და ბლოკი $k$ ($k = 0 ... \lfloor {\ frac n s} \rfloor$) შეიცავს რიცხვებს სეგმენტში $[ks; ks + s - 1]$.
ჩვენ შეგვიძლია ვიმუშაოთ ბლოკებზე მონაცვლეობით, ანუ $k$-ის ყოველი ბლოკისთვის ჩვენ გადავხედავთ ყველა მარტივ რიცხვს ($1$-დან $\sqrt n$-მდე) და შევასრულებთ საცერს მათი გამოყენებით.
აღსანიშნავია, რომ პირველი რიცხვების დამუშავებისას სტრატეგია ოდნავ უნდა შევცვალოთ: პირველი, ყველა მარტივი რიცხვი $[1-დან; \sqrt n]$ არ უნდა მოიხსნას თავი; და მეორე, რიცხვები $0$ და $1$ უნდა იყოს მონიშნული, როგორც არაპირველი რიცხვები.
ბოლო ბლოკზე მუშაობისას არ უნდა დაგვავიწყდეს, რომ ბოლო საჭირო ნომერი $n$ სულაც არ არის განთავსებული ბლოკის ბოლოს.

როგორც ადრე განვიხილეთ, ერატოსთენეს საცრის ტიპიური განხორციელება შემოიფარგლება იმ სიჩქარით, თუ რამდენად სწრაფად შეგიძლიათ ჩატვირთოთ მონაცემები CPU-ის ქეშებში.
პოტენციური მარტივი რიცხვების დიაპაზონის გაყოფით $[1; n]$ უფრო პატარა ბლოკებად, ჩვენ არასდროს გვჭირდება რამდენიმე ბლოკის ერთდროულად შენახვა მეხსიერებაში და ყველა ოპერაცია ბევრად უფრო მოსახერხებელია ქეშისთვის.
იმის გამო, რომ ჩვენ აღარ ვართ შეზღუდული ქეშის სიჩქარით, ჩვენ შეგვიძლია შევცვალოთ `vector<bool>` `vector<char>`-ით და მივიღოთ გარკვეული დამატებითი შესრულება, რადგან პროცესორებს შეუძლიათ წაიკითხონ და წერონ ბაიტებით პირდაპირ და არა' არ უნდა დაეყრდნოთ ბიტის ოპერაციებს ცალკეული ბიტების ამოსაღებად.
საორიენტაციო მაჩვენებელი ([ბმული](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) აჩვენებს, რომ `vector<char>` გამოყენება ამ სიტუაციაში დაახლოებით 3-ჯერ უფრო სწრაფია, ვიდრე `vector<bool>`.
სიფრთხილე: ეს რიცხვები შეიძლება განსხვავდებოდეს არქიტექტურის, შემდგენელისა და ოპტიმიზაციის დონის მიხედვით.

აქ გვაქვს იმპლემენტაცია, რომელიც ითვლის $n$-ზე ნაკლები ან ტოლი პრაიმების რაოდენობას ბლოკის გაცრის გამოყენებით.

```cpp
int count_primes(int n) {
    const int S = 10000;

    vector<int> primes;
    int nsqrt = sqrt(n);
    vector<char> is_prime(nsqrt + 2, true);
    for (int i = 2; i <= nsqrt; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= nsqrt; j += i)
                is_prime[j] = false;
        }
    }

    int result = 0;
    vector<char> block(S);
    for (int k = 0; k * S <= n; k++) {
        fill(block.begin(), block.end(), true);
        int start = k * S;
        for (int p : primes) {
            int start_idx = (start + p - 1) / p;
            int j = max(start_idx, p) * p - start;
            for (; j < S; j += p)
                block[j] = false;
        }
        if (k == 0)
            block[0] = block[1] = false;
        for (int i = 0; i < S && start + i <= n; i++) {
            if (block[i])
                result++;
        }
    }
    return result;
}
```

ბლოკის გაცრის დრო იგივეა, რაც ერატოსთენეს ჩვეულებრივი საცერისთვის (თუ ბლოკების ზომა არ არის ძალიან მცირე), მაგრამ საჭირო მეხსიერება შემცირდება $O(\sqrt{n} + S)$-მდე და გვაქვს უკეთესი ქეშირების შედეგები.
მეორეს მხრივ, იქნება გაყოფა ბლოკის თითოეული წყვილისთვის და მარტივი რიცხვი $[1-დან; \sqrt{n}]$, და ეს ბევრად უარესი იქნება უფრო მცირე ზომის ბლოკებისთვის.
აქედან გამომდინარე, აუცილებელია ბალანსის დაცვა მუდმივი $S$-ის არჩევისას.
ჩვენ მივაღწიეთ საუკეთესო შედეგებს ბლოკის ზომებისთვის $10^4$-დან $10^5$-მდე.

## იპოვნეთ დიაპაზონში დიაპაზონის დიაპაზონი

ზოგჯერ ჩვენ გვჭირდება ყველა მარტივი რიცხვის პოვნა $[L,R]$ მცირე ზომის დიაპაზონში (მაგ. $R - L + 1 \დაახლოებით 1e7$), სადაც $R$ შეიძლება იყოს ძალიან დიდი (მაგ. $1e12$).

ასეთი პრობლემის გადასაჭრელად შეგვიძლია გამოვიყენოთ Segmented sieve-ის იდეა.
ჩვენ წინასწარ ვქმნით ყველა მარტივ რიცხვს $\sqrt R$-მდე და ვიყენებთ ამ მარტივ რიცხვებს $[L, R]$ სეგმენტში ყველა კომპოზიტური რიცხვის აღსანიშნავად.

```cpp
vector<char> segmentedSieve(long long L, long long R) {
    // generate all primes up to sqrt(R)
    long long lim = sqrt(R);
    vector<char> mark(lim + 1, false);
    vector<long long> primes;
    for (long long i = 2; i <= lim; ++i) {
        if (!mark[i]) {
            primes.emplace_back(i);
            for (long long j = i * i; j <= lim; j += i)
                mark[j] = true;
        }
    }

    vector<char> isPrime(R - L + 1, true);
    for (long long i : primes)
        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)
            isPrime[j - L] = false;
    if (L == 1)
        isPrime[0] = false;
    return isPrime;
}
```
ამ მიდგომის დროის სირთულეა $O((R - L + 1) \log \log (R) + \sqrt R \log \log \sqrt R)$.

ასევე შესაძლებელია, რომ ჩვენ წინასწარ არ შევქმნათ ყველა მარტივი რიცხვი:

```cpp
vector<char> segmentedSieveNoPreGen(long long L, long long R) {
    vector<char> isPrime(R - L + 1, true);
    long long lim = sqrt(R);
    for (long long i = 2; i <= lim; ++i)
        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)
            isPrime[j - L] = false;
    if (L == 1)
        isPrime[0] = false;
    return isPrime;
}
```

ცხადია, სირთულე უფრო უარესია, რაც არის $O((R - L + 1) \log (R) + \sqrt R)$. თუმცა, ის მაინც ძალიან სწრაფად მუშაობს პრაქტიკაში.

## დროის ხაზოვანი მოდიფიკაცია

ჩვენ შეგვიძლია შევცვალოთ ალგორითმი ისე, რომ მას ჰქონდეს მხოლოდ წრფივი დროის სირთულე.
ეს მიდგომა აღწერილია სტატიაში [ხაზოვანი საცერი](prime-sieve-linear.md).
თუმცა, ამ ალგორითმს ასევე აქვს თავისი სისუსტეები.

## პრაქტიკული პრობლემები

* [Leetcode - Four Divisors](https://leetcode.com/problems/four-divisors/)
* [Leetcode - Count Primes](https://leetcode.com/problems/count-primes/)
* [SPOJ - Printing Some Primes](http://www.spoj.com/problems/TDPRIMES/)
* [SPOJ - A Conjecture of Paul Erdos](http://www.spoj.com/problems/HS08PAUL/)
* [SPOJ - Primal Fear](http://www.spoj.com/problems/VECTAR8/)
* [SPOJ - Primes Triangle (I)](http://www.spoj.com/problems/PTRI/)
* [Codeforces - Almost Prime](http://codeforces.com/contest/26/problem/A)
* [Codeforces - Sherlock And His Girlfriend](http://codeforces.com/contest/776/problem/B)
* [SPOJ - Namit in Trouble](http://www.spoj.com/problems/NGIRL/)
* [SPOJ - Bazinga!](http://www.spoj.com/problems/DCEPC505/)
* [Project Euler - Prime pair connection](https://www.hackerrank.com/contests/projecteuler/challenges/euler134)
* [SPOJ - N-Factorful](http://www.spoj.com/problems/NFACTOR/)
* [SPOJ - Binary Sequence of Prime Numbers](http://www.spoj.com/problems/BSPRIME/)
* [UVA 11353 - A Different Kind of Sorting](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2338)
* [SPOJ - Prime Generator](http://www.spoj.com/problems/PRIME1/)
* [SPOJ - Printing some primes (hard)](http://www.spoj.com/problems/PRIMES2/)
* [Codeforces - Nodbach Problem](https://codeforces.com/problemset/problem/17/A)
* [Codeforces - Colliders](https://codeforces.com/problemset/problem/154/B)
