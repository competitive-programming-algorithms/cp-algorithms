# წრფივი დიოფანტინის განტოლებები

ხაზოვანი დიოფანტინის განტოლება (ორ ცვლადში) არის ზოგადი ფორმის განტოლება:

$$ax + by = c$$

სადაც $a$, $b$, $c$ მოცემულია ყველა რიცხვი და $x$, $y$ უცნობი მთელი რიცხვები.

ამ სტატიაში განვიხილავთ რამდენიმე კლასიკურ პრობლემას ამ განტოლებებზე:

* ერთი გამოსავლის პოვნა
* ყველა გადაწყვეტის პოვნა
* ამონახსნების რაოდენობის და თავად ამონახსნების პოვნა მოცემულ ინტერვალში
* გადაწყვეტის პოვნა მინიმალური მნიშვნელობით $x + y$

## დეგენერატის შემთხვევა

დეგენერაციული შემთხვევა, რომელიც საჭიროებს ზრუნვას, არის როდესაც $a = b = 0$. ადვილი მისახვედრია, რომ ჩვენ ან არ გვაქვს ამონახსნები ან უსასრულოდ ბევრი ამონახსნები, ეს დამოკიდებულია იმაზე, $c = 0$ თუ არა. ამ სტატიის დანარჩენ ნაწილში ჩვენ უგულებელყოფთ ამ შემთხვევას.

## ანალიტიკური გამოსავალი

როდესაც $a \neq 0$ და $b \neq 0$, განტოლება $ax+by=c$ შეიძლება ექვივალენტურად განიხილებოდეს როგორც რომელიმე ქვემოთ ჩამოთვლილიდან:

\begin{gather}
ax \equiv c \pmod b,\newline
by \equiv c \pmod a.
\end{gather}

ზოგადობის დაკარგვის გარეშე, დავუშვათ, რომ $b \neq 0$ და განიხილეთ პირველი განტოლება. როდესაც $a$ და $b$ თანადაფინანსებულია, გამოსავალი მოცემულია როგორც

$$x \equiv ca^{-1} \pmod b,$$

სადაც $a^{-1}$ არის $a$ modulo $b$-ის [modular inverse](module-inverse.md).

როდესაც $a$ და $b$ არ არიან თანა-პირველი, $ax$ მოდულის $b$ მნიშვნელობები ყველა მთელი რიცხვისთვის $x$ იყოფა $g=\gcd(a, b)$-ზე, ამიტომ გამოსავალი მხოლოდ მაშინ არსებობს, როცა $c$ იყოფა $g$-ზე. ამ შემთხვევაში, ერთ-ერთი ამოხსნის პოვნა შესაძლებელია განტოლების $g$-ით შემცირებით:

$$(a/g) x \equiv (c/g) \pmod{b/g}.$$

$g$-ის განმარტებით, რიცხვები $a/g$ და $b/g$ არის თანდაყოლილი, ასე რომ, ამოხსნა მოცემულია ცალსახად, როგორც

$$\begin{cases}
x \equiv (c/g)(a/g)^{-1}\pmod{b/g},\\
y = \frac{c-ax}{b}.
\end{cases}$$

## ალგორითმული გადაწყვეტა

დიოფანტინის განტოლების 2 უცნობი ამოხსნის საპოვნელად, შეგიძლიათ გამოიყენოთ [გაფართოებული ევკლიდური ალგორითმი](extended-euclid-algorithm.md). პირველი, ვივარაუდოთ, რომ $a$ და $b$ არ არის უარყოფითი. როდესაც ჩვენ ვიყენებთ გაფართოებულ ევკლიდეს ალგორითმს $a$-ისთვის და $b$-ისთვის, ჩვენ შეგვიძლია ვიპოვოთ მათი უდიდესი საერთო გამყოფი $g$ და 2 რიცხვი $x_g$ და $y_g$ ისეთი, რომ:

$$a x_g + b y_g = g$$

თუ $c$ იყოფა $g = \gcd(a, b)$-ზე, მაშინ მოცემულ დიოფანტინის განტოლებას აქვს ამონახსნი, წინააღმდეგ შემთხვევაში მას არ აქვს ამონახსნი. მტკიცებულება პირდაპირია: ორი რიცხვის წრფივი კომბინაცია იყოფა მათ საერთო გამყოფზე.

ახლა ვივარაუდოთ, რომ $c$ იყოფა $g$-ზე, მაშინ გვაქვს:

$$a \cdot x_g \cdot \frac{c}{g} + b \cdot y_g \cdot \frac{c}{g} = c$$

ამიტომ დიოფანტინის განტოლების ერთ-ერთი ამონახსნებია:

$$x_0 = x_g \cdot \frac{c}{g},$$

$$y_0 = y_g \cdot \frac{c}{g}.$$

ზემოაღნიშნული იდეა კვლავ მუშაობს, როდესაც $a$ ან $b$ ან ორივე მათგანი უარყოფითია. საჭიროების შემთხვევაში მხოლოდ $x_0$ და $y_0$ უნდა შევცვალოთ ნიშანი.

საბოლოოდ, ჩვენ შეგვიძლია განვახორციელოთ ეს იდეა შემდეგნაირად (გაითვალისწინეთ, რომ ეს კოდი არ განიხილავს შემთხვევას $a = b = 0$):

```{.cpp file=linear_diophantine_any}
int gcd(int a, int b, int& x, int& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int x1, y1;
    int d = gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - y1 * (a / b);
    return d;
}

bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {
    g = gcd(abs(a), abs(b), x0, y0);
    if (c % g) {
        return false;
    }

    x0 *= c / g;
    y0 *= c / g;
    if (a < 0) x0 = -x0;
    if (b < 0) y0 = -y0;
    return true;
}
```

## ყველა გადაწყვეტის მიღება

$(x_0, y_0)$ ერთი ამონახსნებიდან შეგვიძლია მივიღოთ მოცემული განტოლების ყველა ამონახსნი.

მოდით $g = \gcd(a, b)$ და $x_0, y_0$ იყოს მთელი რიცხვები, რომლებიც აკმაყოფილებენ შემდეგს:

$$a \cdot x_0 + b \cdot y_0 = c$$

ახლა ჩვენ უნდა დავინახოთ, რომ $b / g$-ის დამატება $x_0$-ზე და, ამავე დროს, $a / g$-ის გამოკლება $y_0$-ს არ დაარღვევს თანასწორობას:

$$a \cdot \left(x_0 + \frac{b}{g}\right) + b \cdot \left(y_0 - \frac{a}{g}\right) = a \cdot x_0 + b \cdot y_0 + a \cdot \frac{b}{g} - b \cdot \frac{a}{g} = c$$

ცხადია, ეს პროცესი შეიძლება კვლავ განმეორდეს, ასე რომ, ფორმის ყველა ნომერი:

$$x = x_0 + k \cdot \frac{b}{g}$$

$$y = y_0 - k \cdot \frac{a}{g}$$

არის მოცემული დიოფანტინის განტოლების ამონახსნები.

უფრო მეტიც, ეს არის მოცემული დიოფანტინის განტოლების ყველა შესაძლო ამონახსნის ნაკრები.

## ამონახსნების რაოდენობის პოვნა მოცემულ ინტერვალში
წინა განყოფილებიდან ცხადი უნდა იყოს, რომ თუ ჩვენ არ დავაწესებთ რაიმე შეზღუდვას გადაწყვეტილებებზე, იქნება მათი უსასრულო რაოდენობა. ამ განყოფილებაში ჩვენ ვამატებთ შეზღუდვებს $x$-ისა და $y$-ის ინტერვალზე და შევეცდებით ყველა ამონახსნის დათვლას და ჩამოთვლას.

იყოს ორი ინტერვალი: $[min_x; max_x]$ და $[მინ_წ; max_y]$ და ვთქვათ, რომ მხოლოდ ამ ორ ინტერვალში გვინდა ამონახსნების პოვნა.

გაითვალისწინეთ, რომ თუ $a$ ან $b$ არის $0$, მაშინ პრობლემას მხოლოდ ერთი გამოსავალი აქვს. ჩვენ აქ არ განვიხილავთ ამ შემთხვევას.

პირველი, ჩვენ შეგვიძლია ვიპოვოთ გამოსავალი, რომელსაც აქვს მინიმალური მნიშვნელობა $x$, ისეთი, რომ $x \ge min_x$. ამისათვის ჩვენ ჯერ ვიპოვით დიოფანტინის განტოლების ნებისმიერ ამონახსანს. შემდეგ, ჩვენ გადავცვლით ამ ამონახსნებს, რათა მივიღოთ $x \ge min_x$ (გამოვიყენოთ ის, რაც ვიცით წინა განყოფილების ყველა ამონახსნის სიმრავლის შესახებ). ეს შეიძლება გაკეთდეს $O(1)$-ში.
აღნიშნეთ ეს მინიმალური მნიშვნელობა $x$-ით $l_{x1}$-ით.

ანალოგიურად, ჩვენ შეგვიძლია ვიპოვოთ $x$-ის მაქსიმალური მნიშვნელობა, რომელიც აკმაყოფილებს $x \le max_x$-ს. აღნიშნეთ $x$-ის ეს მაქსიმალური მნიშვნელობა $r_{x1}$-ით.

საბოლოო ამონახსნები არის ყველა ამონახსნი x-ით $[l_{x1}, r_{x1}]$ და $[l_{x2}, r_{x2}]$-ის კვეთაზე. მოდით აღვნიშნოთ ეს კვეთა $[l_x, r_x]$-ით.

ქვემოთ მოცემულია ამ იდეის განმახორციელებელი კოდი.
ყურადღება მიაქციეთ, რომ დასაწყისში $a$ და $b$ ვყოფთ $g$-ზე.
ვინაიდან განტოლება $a x + b y = c$ არის $\frac{a}{g} x + \frac{b}{g} y = \frac{c}{g}$ განტოლების ექვივალენტური, ჩვენ შეგვიძლია გამოვიყენოთ ეს ერთი ნაცვლად და აქვს $\gcd(\frac{a}{g}, \frac{b}{g}) = 1$, რაც ამარტივებს ფორმულებს.

```{.cpp file=linear_diophantine_all}
void shift_solution(int & x, int & y, int a, int b, int cnt) {
    x += cnt * b;
    y -= cnt * a;
}

int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {
    int x, y, g;
    if (!find_any_solution(a, b, c, x, y, g))
        return 0;
    a /= g;
    b /= g;

    int sign_a = a > 0 ? +1 : -1;
    int sign_b = b > 0 ? +1 : -1;

    shift_solution(x, y, a, b, (minx - x) / b);
    if (x < minx)
        shift_solution(x, y, a, b, sign_b);
    if (x > maxx)
        return 0;
    int lx1 = x;

    shift_solution(x, y, a, b, (maxx - x) / b);
    if (x > maxx)
        shift_solution(x, y, a, b, -sign_b);
    int rx1 = x;

    shift_solution(x, y, a, b, -(miny - y) / a);
    if (y < miny)
        shift_solution(x, y, a, b, -sign_a);
    if (y > maxy)
        return 0;
    int lx2 = x;

    shift_solution(x, y, a, b, -(maxy - y) / a);
    if (y > maxy)
        shift_solution(x, y, a, b, sign_a);
    int rx2 = x;

    if (lx2 > rx2)
        swap(lx2, rx2);
    int lx = max(lx1, lx2);
    int rx = min(rx1, rx2);

    if (lx > rx)
        return 0;
    return (rx - lx) / abs(b) + 1;
}
```

მას შემდეგ რაც გვექნება $l_x$ და $r_x$, ასევე მარტივია ყველა ამოხსნის ჩამოთვლა. უბრალოდ უნდა გაიმეოროთ $x = l_x + k \cdot \frac{b}{g}$ ყველა $k \ge 0$-მდე $x = r_x$-მდე და იპოვოთ შესაბამისი $y$ მნიშვნელობები $a x განტოლების გამოყენებით. + b y = c$.

### იპოვეთ ამონახსნი მინიმალური მნიშვნელობით $x + y$ { data-toc-label='იპოვეთ ამონახსნები მინიმალური მნიშვნელობით <script type="math/tex">x + y</script>' }

აქ, $x$ და $y$ ასევე უნდა მიენიჭოს გარკვეული შეზღუდვა, წინააღმდეგ შემთხვევაში, პასუხი შეიძლება გახდეს უარყოფითი უსასრულობა.

იდეა წინა განყოფილების მსგავსია: ჩვენ ვპოულობთ დიოფანტინის განტოლების ნებისმიერ ამონახსანს და შემდეგ გადავიტანთ ამონახსნებს გარკვეული პირობების დასაკმაყოფილებლად.

დაბოლოს, გამოიყენეთ ყველა გადაწყვეტილებების ნაკრების ცოდნა მინიმუმის მოსაძებნად:

$$x' = x + k \cdot \frac{b}{g},$$

$$y' = y - k \cdot \frac{a}{g}.$$

გაითვალისწინეთ, რომ $x + y$ იცვლება შემდეგნაირად:

$$x' + y' = x + y + k \cdot \left(\frac{b}{g} - \frac{a}{g}\right) = x + y + k \cdot \frac{b-a}{g}$$

თუ $a < b$, ჩვენ უნდა ავირჩიოთ $k$-ის უმცირესი შესაძლო მნიშვნელობა. თუ $a > b$, ჩვენ უნდა ავირჩიოთ $k$-ის ყველაზე დიდი შესაძლო მნიშვნელობა. თუ $a = b$, ყველა ამოხსნას ექნება იგივე ჯამი $x + y$.

## პრაქტიკიული პრობლემები

* [Spoj - Crucial Equation](http://www.spoj.com/problems/CEQU/)
* [SGU 106](http://codeforces.com/problemsets/acmsguru/problem/99999/106)
* [Codeforces - Ebony and Ivory](http://codeforces.com/contest/633/problem/A)
* [Codechef - Get AC in one go](https://www.codechef.com/problems/COPR16G)
* [LightOj - Solutions to an equation](http://www.lightoj.com/volume_showproblem.php?problem=1306)
* [Atcoder - F - S = 1](https://atcoder.jp/contests/abc340/tasks/abc340_f)


