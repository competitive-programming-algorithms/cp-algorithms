---
tags:
  - Translated
e_maxx_link: stacks_for_minima
---

# მინიმალური დასტა / მინიმალური რიგი

ამ სტატიაში განვიხილავთ სამ პრობლემას:
ჯერ ჩვენ შევცვლით სტეკს ისე, რომ საშუალებას მოგვცემს ვიპოვოთ სტეკის უმცირესი ელემენტი $O(1)$-ში, შემდეგ იგივეს გავაკეთებთ რიგით და ბოლოს გამოვიყენებთ ამ მონაცემთა სტრუქტურებს საპოვნელად. მინიმალური $O(n)$-ში ფიქსირებული სიგრძის ყველა ქვემასივში

## სტეკის მოდიფიკაცია

ჩვენ გვინდა შევცვალოთ სტეკის მონაცემთა სტრუქტურა ისე, რომ შესაძლებელი გახდეს სტეკში უმცირესი ელემენტის პოვნა $O(1)$ დროში, ხოლო შენარჩუნებული იყოს იგივე ასიმპტომური ქცევა დასტადან ელემენტების დამატებისა და ამოღების მიზნით.
სწრაფი შეხსენება, დასტაზე ჩვენ მხოლოდ ერთ ბოლოზე ვამატებთ და ვაშორებთ ელემენტებს.

ამისთვის, ჩვენ არა მარტო ვინახავთ ელემენტებს სტეკში, არამედ ვინახავთ მათ წყვილებად: თავად ელემენტს და მინიმუმს სტეკში, დაწყებული ამ ელემენტიდან და ქვემოთ.

```cpp
stack<pair<int, int>> st;
```

ცხადია, რომ მინიმუმის პოვნა მთელ დასტაში შედგება მხოლოდ `stack.top().second` მნიშვნელობის ნახვით.

ასევე აშკარაა, რომ დასტაზე ახალი ელემენტის დამატება ან ამოღება შეიძლება მოხდეს მუდმივ დროში.

განხორციელება:

* ელემენტის დამატება:
```cpp
int new_min = st.empty() ? new_elem : min(new_elem, st.top().second);
st.push({new_elem, new_min});
```

* ელემენტის ამოღება:
```cpp
int removed_element = st.top().first;
st.pop();
```

* მინიმალურის პოვნა:
```cpp
int minimum = st.top().second;
```

## რიგის მოდიფიკაცია (მეთოდი 1)

ახლა ჩვენ გვინდა მივაღწიოთ იგივე ოპერაციებს რიგით, ანუ ჩვენ გვინდა დავამატო ელემენტები ბოლოს და წავშალოთ ისინი წინა მხრიდან.

აქ განვიხილავთ რიგის შეცვლის მარტივ მეთოდს.
თუმცა მას აქვს დიდი მინუსი, რადგან შეცვლილი რიგი რეალურად არ ინახავს ყველა ელემენტს.

მთავარი იდეა არის რიგში მხოლოდ იმ ნივთების შენახვა, რაც საჭიროა მინიმუმის დასადგენად.
კერძოდ, ჩვენ შევინარჩუნებთ რიგს შეუმცირებელი თანმიმდევრობით (ანუ ყველაზე მცირე მნიშვნელობა შეინახება თავში) და, რა თქმა უნდა, არა რაიმე თვითნებურად, ფაქტობრივი მინიმუმი ყოველთვის უნდა იყოს შეტანილი რიგში.
ამ გზით ყველაზე პატარა ელემენტი ყოველთვის იქნება რიგის თავში.
რიგში ახალი ელემენტის დამატებამდე, საკმარისია გააკეთოთ "cut":
ჩვენ ამოვიღებთ რიგის ყველა უკანა ელემენტს, რომელიც უფრო დიდია ვიდრე ახალი ელემენტი და შემდეგ დავამატებთ ახალ ელემენტს რიგში.
ამ გზით ჩვენ არ ვარღვევთ რიგის წესრიგს და ასევე არ დავკარგავთ მიმდინარე ელემენტს, თუ ის ნებისმიერ მომდევნო ეტაპზე იქნება მინიმალური.
ყველა ელემენტი, რომელიც ჩვენ წავშალეთ, ვერასოდეს იქნება მინიმუმი, ამიტომ ეს ოპერაცია ნებადართულია.
როდესაც ჩვენ გვინდა ელემენტის ამოღება თავიდან, ის შეიძლება რეალურად არ იყოს (რადგან ადრე წავშალეთ იგი პატარა ელემენტის დამატებისას).
ამიტომ, რიგიდან ელემენტის წაშლისას უნდა ვიცოდეთ ელემენტის მნიშვნელობა.
თუ რიგის ხელმძღვანელს იგივე მნიშვნელობა აქვს, შეგვიძლია უსაფრთხოდ ამოიღოთ იგი, წინააღმდეგ შემთხვევაში არაფერს ვაკეთებთ.

განვიხილოთ ზემოაღნიშნული ოპერაციების განხორციელება:

```cpp
deque<int> q;
```

* მინიმალურის პოვნა:
```cpp
int minimum = q.front();
```

* ელემენტის დამატება:
```cpp
while (!q.empty() && q.back() > new_element)
    q.pop_back();
q.push_back(new_element);
```

* ელემენტის ამოღება:
```cpp
if (!q.empty() && q.front() == remove_element)
    q.pop_front();
```

ცხადია, რომ ყველა ამ ოპერაციას საშუალოდ მხოლოდ $O(1)$ დრო სჭირდება (რადგან ყველა ელემენტის დაძაბვა და ამოღება შესაძლებელია მხოლოდ ერთხელ).

## რიგის მოდიფიკაცია (მეთოდი 2)

ეს არის 1 მეთოდის მოდიფიკაცია.
ჩვენ გვინდა შევძლოთ ელემენტების ამოღება ისე, რომ არ ვიცოდეთ რომელი ელემენტი უნდა წავშალოთ.
ჩვენ შეგვიძლია მივაღწიოთ ამას რიგში თითოეული ელემენტის ინდექსის შენახვით.
ჩვენ ასევე გვახსოვს რამდენი ელემენტი უკვე დავამატეთ და ამოიღეთ.

```cpp
deque<pair<int, int>> q;
int cnt_added = 0;
int cnt_removed = 0;
```

* მინიმალურის პოვნა:
```cpp
int minimum = q.front().first;
```

* ელემენტის დამატება:
```cpp
while (!q.empty() && q.back().first > new_element)
    q.pop_back();
q.push_back({new_element, cnt_added});
cnt_added++;
```

* ელემენტის ამოღება:
```cpp
if (!q.empty() && q.front().second == cnt_removed) 
    q.pop_front();
cnt_removed++;
```

## რიგის მოდიფიკაცია (მეთოდი 3)

აქ განვიხილავთ რიგის შეცვლის სხვა ხერხს, რათა ვიპოვოთ მინიმუმი $O(1)$-ში.
ამ ხერხის განხორციელება გარკვეულწილად უფრო რთულია, მაგრამ ამჯერად ჩვენ რეალურად ვინახავთ ყველა ელემენტს.
ჩვენ ასევე შეგვიძლია ამოიღოთ ელემენტი წინა მხრიდან მისი მნიშვნელობის ცოდნის გარეშე.

იდეა მდგომარეობს იმაში, რომ პრობლემა დავიყვანოთ სტეკების პრობლემამდე, რომელიც უკვე მოგვარებულია ჩვენ მიერ.
ასე რომ, ჩვენ მხოლოდ უნდა ვისწავლოთ რიგის სიმულაცია ორი სტეკის გამოყენებით.

ჩვენ ვაკეთებთ ორ დასტას, `s1` და `s2`.
რა თქმა უნდა, ეს დასტა იქნება შეცვლილი ფორმის, ასე რომ ჩვენ შეგვიძლია ვიპოვოთ მინიმალური $O(1)$-ში.
ჩვენ დავამატებთ ახალ ელემენტებს სტეკში `s1`, ხოლო ელემენტებს წავშლით დასტიდან `s2`.
თუ ნებისმიერ დროს დასტა `s2` ცარიელია, ჩვენ ყველა ელემენტს გადავიტანთ `s1`-დან `s2`-ზე (რაც არსებითად ცვლის ამ ელემენტების თანმიმდევრობას).
ბოლოს რიგში მინიმუმის პოვნა გულისხმობს მხოლოდ ორივე სტეკის მინიმუმის პოვნას.

ამრიგად, ჩვენ ვასრულებთ ყველა ოპერაციას $O(1)$-ში საშუალოდ (თითოეული ელემენტი ერთხელ დაემატება დასტას `s1`, ერთხელ გადაეცემა `s2`-ში და ერთხელ ამოვა `s2`-დან).

Implementation:

```cpp
stack<pair<int, int>> s1, s2;
```

* მინიმალურის პოვნა:
```cpp
if (s1.empty() || s2.empty()) 
    minimum = s1.empty() ? s2.top().second : s1.top().second;
else
    minimum = min(s1.top().second, s2.top().second);
```

* ელემენტის დამატება:
```cpp
int minimum = s1.empty() ? new_element : min(new_element, s1.top().second);
s1.push({new_element, minimum});
```

* ელემენტის წაშლა:
```cpp
if (s2.empty()) {
    while (!s1.empty()) {
        int element = s1.top().first;
        s1.pop();
        int minimum = s2.empty() ? element : min(element, s2.top().second);
        s2.push({element, minimum});
    }
}
int remove_element = s2.top().first;
s2.pop();
```

## მინიმალურის პოვნა ფიქსირებული სიგრძის ყველა ქვემასივისთვის

დავუშვათ, რომ გვეძლევა $N$ სიგრძის $A$ და $M \le N$.
ამ მასივში უნდა ვიპოვოთ $M$ სიგრძის თითოეული ქვემასივის მინიმალური, ანუ უნდა ვიპოვოთ:

$$\min_{0 \le i \le M-1} A[i], \min_{1 \le i \le M} A[i], \min_{2 \le i \le M+1} A[i],~\dots~, \min_{N-M \le i \le N-1} A[i]$$

ეს პრობლემა უნდა გადავჭრათ წრფივ დროში, ანუ $O(n)$.

პრობლემის გადასაჭრელად შეგვიძლია გამოვიყენოთ სამი შეცვლილი რიგიდან რომელიმე.
გადაწყვეტილებები უნდა იყოს ნათელი:
ჩვენ ვამატებთ მასივის პირველ $M$ ელემენტს, ვპოულობთ და გამოვყოფთ მის მინიმუმს, შემდეგ ვამატებთ მომდევნო ელემენტს რიგში და ვხსნით მასივის პირველ ელემენტს, ვიპოვით და გამოვატანთ მის მინიმუმს და ა.შ.
ვინაიდან რიგთან დაკავშირებული ყველა ოპერაცია საშუალოდ შესრულებულია მუდმივ დროში, მთელი ალგორითმის სირთულე იქნება $O(n)$.

## სავარჯიშო
* [Queries with Fixed Length](https://www.hackerrank.com/challenges/queries-with-fixed-length/problem)
* [Binary Land](https://www.codechef.com/MAY20A/problems/BINLAND)

