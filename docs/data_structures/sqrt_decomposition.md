---
tags:
  - Translated
e_maxx_link: sqrt_decomposition
---

# კვადრატული ფესვის დაშლა (Sqrt Decomposition)

კვადრატული ფესვის დაშლა არის მეთოდი (ან მონაცემთა სტრუქტურა), რომელიც საშუალებას გაძლევთ შეასრულოთ რამდენიმე საერთო ოპერაციები (ქვემასივის ელემენტების ჯამის პოვნა, მინიმალური/მაქსიმალური ელემენტის და ა.შ.) $O(\sqrt n)$-ში. ოპერაციები, რაც ბევრად უფრო სწრაფია ვიდრე $O(n)$ ტრივიალური ალგორითმისთვის.

ჯერ ჩვენ აღვწერთ მონაცემთა სტრუქტურას ამ იდეის ერთ-ერთი უმარტივესი აპლიკაციისთვის, შემდეგ ვაჩვენებთ, თუ როგორ განვაზოგადოთ იგი სხვა პრობლემების გადასაჭრელად და ბოლოს გადავხედავთ ამ იდეის ოდნავ განსხვავებულ გამოყენებას: შეყვანის მოთხოვნების დაყოფა კვადრატული ფესვის ბლოკებად.
## კვადრატული ფესვის (Sqrt)-დაშლაზე დაფუძნებული მონაცემთა სტრუქტურა

$a[0 \dots n-1]$ მასივის გათვალისწინებით, დანერგეთ მონაცემთა სტრუქტურა, რომელიც საშუალებას გაძლევთ იპოვოთ $a[l \dots r]$ ელემენტების ჯამი თვითნებური $l$-ისთვის და $r$-ში $O( \sqrt n)$ ოპერაციები.

### აღწერა

sqrt დაშლის ძირითადი იდეა არის წინასწარი დამუშავება. $a$ მასივს დავყოფთ დაახლოებით $\sqrt n$ სიგრძის ბლოკებად და თითოეული $i$ ბლოკისთვის წინასწარ გამოვთვლით მასში შემავალი ელემენტების ჯამს $b[i]$.

შეგვიძლია ვივარაუდოთ, რომ ბლოკის ზომაც და ბლოკების რაოდენობაც უდრის $\sqrt n$-ის დამრგვალებას:

$$ s = \lceil \sqrt n \rceil $$

შემდეგ მასივი $a$ იყოფა ბლოკებად შემდეგი გზით:

$$ \underbrace{a[0], a[1], \dots, a[s-1]}_{\text{b[0]}}, \underbrace{a[s], \dots, a[2s-1]}_{\text{b[1]}}, \dots, \underbrace{a[(s-1) \cdot s], \dots, a[n-1]}_{\text{b[s-1]}} $$

ბოლო ბლოკს შეიძლება ჰქონდეს ნაკლები ელემენტები, ვიდრე სხვები (თუ $n$ არ არის $s$-ის ჯერადი), ეს არ არის მნიშვნელოვანი დისკუსიისთვის (რადგან ადვილია მისი დამუშავება).
ამრიგად, თითოეული $k$ ბლოკისთვის ჩვენ ვიცით მასზე არსებული ელემენტების ჯამი $b[k]$:

$$ b[k] = \sum\limits_{i=k\cdot s}^{\min {(n-1,(k+1)\cdot s - 1})} a[i] $$

ასე რომ, ჩვენ გამოვთვალეთ $b[k]$-ის მნიშვნელობები (ამისთვის საჭიროა $O(n)$ ოპერაციები). როგორ დაგვეხმარებიან ისინი $[l, r]$-ის თითოეულ შეკითხვაზე პასუხის გაცემაში?
გაითვალისწინეთ, რომ თუ $[l, r]$ ინტერვალი საკმარისად გრძელია, ის შეიცავს რამდენიმე მთლიან ბლოკს და ამ ბლოკებისთვის შეგვიძლია ვიპოვოთ მათში არსებული ელემენტების ჯამი ერთ ოპერაციაში. შედეგად, $[l, r]$ ინტერვალი შეიცავს მხოლოდ ორი ბლოკის ნაწილებს და ამ ნაწილების ელემენტების ჯამი ტრივიალურად უნდა გამოვთვალოთ.

ამრიგად, იმისათვის, რომ გამოვთვალოთ ელემენტების ჯამი $[l, r]$ ინტერვალზე, საჭიროა მხოლოდ ორი "კუდის" ელემენტების ჯამი:
$[l\dots (k + 1)\cdot s-1]$ და $[p\cdot s\dots r]$ და შეაჯამეთ $b[i]$ მნიშვნელობები ყველა ბლოკში $k + 1$-დან $p-1$-მდე:

$$ \sum\limits_{i=l}^r a[i] = \sum\limits_{i=l}^{(k+1) \cdot s-1} a[i] + \sum\limits_{i=k+1}^{p-1} b[i] + \sum\limits_{i=p\cdot s}^r a[i] $$

_შენიშვნა: როდესაც $k = p$, ანუ $l$ და $r$ მიეკუთვნება ერთსა და იმავე ბლოკს, ფორმულის გამოყენება შეუძლებელია და ჯამი უნდა გამოითვალოს ტრივიალურად._

ეს მიდგომა საშუალებას გვაძლევს მნიშვნელოვნად შევამციროთ ოპერაციების რაოდენობა. მართლაც, თითოეული "კუდის" ზომა არ აღემატება $s$ ბლოკის სიგრძეს, ხოლო ჯამში ბლოკების რაოდენობა არ აღემატება $s$-ს. ვინაიდან ჩვენ ავირჩიეთ $s \დაახლოებით \sqrt n$, $[l, r]$ ინტერვალზე ელემენტების ჯამის საპოვნელად საჭირო ოპერაციების ჯამური რაოდენობა არის $O(\sqrt n)$.
### განხორციელება

დავიწყოთ უმარტივესი განხორციელებით:

```cpp
// input data
int n;
vector<int> a (n);

// preprocessing
int len = (int) sqrt (n + .0) + 1; // size of the block and the number of blocks
vector<int> b (len);
for (int i=0; i<n; ++i)
    b[i / len] += a[i];

// answering the queries
for (;;) {
    int l, r;
  // read input data for the next query
    int sum = 0;
    for (int i=l; i<=r; )
        if (i % len == 0 && i + len - 1 <= r) {
            // if the whole block starting at i belongs to [l, r]
            sum += b[i / len];
            i += len;
        }
        else {
            sum += a[i];
            ++i;
        }
}
```

ამ განხორციელებას აქვს არაგონივრულად ბევრი გაყოფის ოპერაცია (რომლებიც ბევრად უფრო ნელია ვიდრე სხვა არითმეტიკული ოპერაციები). ამის ნაცვლად, ჩვენ შეგვიძლია გამოვთვალოთ $c_l$ და $c_r$ ბლოკების ინდექსები, რომლებიც შეიცავენ $l$ და $r$ ინდექსებს, და გავატაროთ $c_l+1 \dots c_r-1$ ბლოკებში "კუდების" ცალკეული დამუშავებით. $c_l$ და $c_r$ ბლოკებში. ეს მიდგომა შეესაბამება აღწერის ბოლო ფორმულას და $c_l = c_r$ შემთხვევას განსაკუთრებულ შემთხვევად აქცევს.

```cpp
int sum = 0;
int c_l = l / len,   c_r = r / len;
if (c_l == c_r)
    for (int i=l; i<=r; ++i)
        sum += a[i];
else {
    for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)
        sum += a[i];
    for (int i=c_l+1; i<=c_r-1; ++i)
        sum += b[i];
    for (int i=c_r*len; i<=r; ++i)
        sum += a[i];
}
```

## სხვა პრობლემები

აქამდე განვიხილავდით უწყვეტი ქვემასივის ელემენტების ჯამის პოვნის პრობლემას. ეს პრობლემა შეიძლება გაფართოვდეს, რათა **განახლდეს მასივის ცალკეული ელემენტები**. თუ $a[i]$ ელემენტი იცვლება, საკმარისია განაახლოთ $b[k]$ მნიშვნელობა იმ ბლოკისთვის, რომელსაც ეკუთვნის ეს ელემენტი ($k = i / s$) ერთი ოპერაციით:

$$ b[k] += a_{new}[i] - a_{old}[i] $$

მეორეს მხრივ, ელემენტების ჯამის პოვნის ამოცანა შეიძლება შეიცვალოს ქვემაივის მინიმალური/მაქსიმალური ელემენტის პოვნის ამოცანებით. თუ ამ პრობლემას უნდა შეეხოს ცალკეული ელემენტების განახლებებიც, $b[k]$-ის მნიშვნელობის განახლება ასევე შესაძლებელია, მაგრამ ის მოითხოვს $k$ ბლოკის ყველა მნიშვნელობის გამეორებას $O(s) = O(\-ში. sqrt{n})$ ოპერაციები.

Sqrt დაშლა შეიძლება გამოყენებულ იქნას სხვა პრობლემების მთელი კლასის ანალოგიურად: ნულოვანი ელემენტების რაოდენობის პოვნა, პირველი არანულოვანი ელემენტის პოვნა, ელემენტების დათვლა, რომლებიც აკმაყოფილებენ გარკვეულ თვისებას და ა.შ.

პრობლემების კიდევ ერთი კლასი ჩნდება, როდესაც ჩვენ გვჭირდება ** მასივის ელემენტების განახლება ინტერვალებით **: არსებული ელემენტების გაზრდა ან მათი ჩანაცვლება მოცემული მნიშვნელობით.

მაგალითად, ვთქვათ, ჩვენ შეგვიძლია გავაკეთოთ ორი ტიპის ოპერაცია მასივზე: დავამატოთ $\delta$ მოცემული მნიშვნელობა მასივის ყველა ელემენტს $[l, r]$-ის ინტერვალზე ან შევიკითხოთ $a[i]$ ელემენტის მნიშვნელობა. მოდით შევინახოთ მნიშვნელობა, რომელიც უნდა დაემატოს $k$ ბლოკის ყველა ელემენტს $b[k]$-ში (თავდაპირველად ყველა $b[k] = 0$). ყოველი "დამატების" ოპერაციის დროს ჩვენ უნდა დავამატოთ $\delta$ $b[k]$-ს ყველა ბლოკისთვის, რომელიც ეკუთვნის $[l, r]$ ინტერვალს და დავამატოთ $\delta$ $a[i]$-ს. ყველა ელემენტი, რომელიც ეკუთვნის ინტერვალის "კუდებს". $i$ შეკითხვაზე პასუხი არის უბრალოდ $a[i] + b[i/s]$. ამ გზით "დამატების" ოპერაციას აქვს $O(\sqrt{n})$ სირთულე, ხოლო შეკითხვაზე პასუხის გაცემას აქვს $O(1)$ სირთულე.

საბოლოოდ, ამ ორი კლასის პრობლემები შეიძლება გაერთიანდეს, თუ დავალება მოითხოვს **ორივე** ელემენტის განახლებას ინტერვალზე და მოთხოვნების ინტერვალზე. ორივე ოპერაცია შეიძლება შესრულდეს $O(\sqrt{n})$ სირთულით. ამას დასჭირდება ორი ბლოკის მასივი $b$ და $c$: ერთი ელემენტის განახლებების თვალყურის დევნებისთვის და მეორე შეკითხვაზე პასუხების თვალყურის დევნებისთვის.

არსებობს სხვა პრობლემები, რომელთა გადაჭრა შესაძლებელია sqrt დაშლის გამოყენებით, მაგალითად, რიცხვების სიმრავლის შენარჩუნების პრობლემა, რომელიც საშუალებას მოგცემთ დაამატოთ/წაშალოთ რიცხვები, შევამოწმოთ არის თუ არა რიცხვი სიმრავლეს და ვიპოვოთ $k$-th უდიდესი რიცხვი. მის გადასაჭრელად უნდა შეინახოთ რიცხვები გაზრდილი თანმიმდევრობით, დაიყოთ რამდენიმე ბლოკად $\sqrt{n}$ ნომრებით თითოეულში. ყოველ ჯერზე, როცა რიცხვი დაემატება/წაშლილია, ბლოკები უნდა დაბალანსდეს ნომრების გადაადგილებით მიმდებარე ბლოკების საწყისებსა და ბოლოებს შორის.
## მო-ს ალგორითმი

მსგავსი იდეა, რომელიც ეფუძნება sqrt დაშლას, შეიძლება გამოყენებულ იქნას დიაპაზონის შეკითხვებზე ($Q$) ხაზგარეშე პასუხის გასაცემად $O((N+Q)\sqrt{N})$-ში.
ეს შეიძლება ბევრად უარესად ჟღერდეს, ვიდრე წინა სექციაში მოცემული მეთოდები, რადგან ეს არის ოდნავ უარესი სირთულე, ვიდრე ადრე გვქონდა და ვერ განაახლებს მნიშვნელობებს ორ მოთხოვნას შორის.
მაგრამ ბევრ სიტუაციაში ამ მეთოდს აქვს უპირატესობები.
ნორმალური sqrt დაშლის დროს, ჩვენ წინასწარ უნდა გამოვთვალოთ პასუხები თითოეული ბლოკისთვის და გავაერთიანოთ ისინი შეკითხვებზე პასუხის გაცემისას.
ზოგიერთ პრობლემაში შერწყმის ეს ნაბიჯი შეიძლება საკმაოდ პრობლემური იყოს.
Მაგალითად. როდესაც თითოეული მოთხოვნა ითხოვს იპოვოთ მისი დიაპაზონის **რეჟიმი** (რიცხვი, რომელიც ყველაზე ხშირად ჩანს).
ამისათვის თითოეულ ბლოკს უნდა შეენახოს მასში არსებული თითოეული რიცხვის რაოდენობა რაიმე სახის მონაცემთა სტრუქტურაში და ჩვენ აღარ შეგვიძლია შერწყმის ნაბიჯის შესრულება საკმაოდ სწრაფად.
**Mo-ს ალგორითმი** იყენებს სრულიად განსხვავებულ მიდგომას, რომელსაც შეუძლია სწრაფად უპასუხოს ამ ტიპის შეკითხვებს, რადგან ის აკონტროლებს მხოლოდ მონაცემთა ერთ სტრუქტურას და მასთან ერთად ოპერაციები მარტივი და სწრაფია.

იდეა არის კითხვებზე პასუხის გაცემა სპეციალური თანმიმდევრობით, ინდექსების საფუძველზე.
ჩვენ ჯერ ვუპასუხებთ ყველა შეკითხვას, რომელსაც აქვს მარცხენა ინდექსი ბლოკში 0, შემდეგ ვპასუხობთ ყველა შეკითხვას, რომელსაც აქვს მარცხენა ბლოკი 1 და ასე შემდეგ.
ასევე, ჩვენ მოგვიწევს პასუხის გაცემა ბლოკის სპეციალური ბრძანებით, კერძოდ, დალაგებულია მოთხოვნების სწორი ინდექსით.

როგორც უკვე ითქვა, ჩვენ გამოვიყენებთ მონაცემთა ერთიან სტრუქტურას.
მონაცემთა ეს სტრუქტურა შეინახავს ინფორმაციას დიაპაზონის შესახებ.
დასაწყისში ეს დიაპაზონი ცარიელი იქნება.
როდესაც გვსურს ვუპასუხოთ შემდეგ შეკითხვას (სპეციალური თანმიმდევრობით), ჩვენ უბრალოდ ვაგრძელებთ ან ვამცირებთ დიაპაზონს მიმდინარე დიაპაზონის ორივე მხარეს ელემენტების დამატებით/მოხსნით, სანამ არ გარდავქმნით მას შეკითხვის დიაპაზონში.
ამ გზით, ჩვენ მხოლოდ ერთხელ გვჭირდება ერთი ელემენტის დამატება ან ამოღება, რაც საკმაოდ მარტივი ოპერაციები უნდა იყოს ჩვენს მონაცემთა სტრუქტურაში.

ვინაიდან ჩვენ ვცვლით შეკითხვებზე პასუხების თანმიმდევრობას, ეს შესაძლებელია მხოლოდ მაშინ, როდესაც უფლებას გვაძლევს ვუპასუხოთ შეკითხვებს ოფლაინ რეჟიმში.

### განხორციელება

Mo-ის ალგორითმში ჩვენ ვიყენებთ ორ ფუნქციას ინდექსის დასამატებლად და ინდექსის ამოსაღებად იმ დიაპაზონიდან, რომელსაც ამჟამად ვინახავთ.

```cpp
void remove(idx);  // TODO: remove value at idx from data structure
void add(idx);     // TODO: add value at idx from data structure
int get_answer();  // TODO: extract the current answer of the data structure

int block_size;

struct Query {
    int l, r, idx;
    bool operator<(Query other) const
    {
        return make_pair(l / block_size, r) <
               make_pair(other.l / block_size, other.r);
    }
};

vector<int> mo_s_algorithm(vector<Query> queries) {
    vector<int> answers(queries.size());
    sort(queries.begin(), queries.end());

    // TODO: initialize data structure

    int cur_l = 0;
    int cur_r = -1;
    // invariant: data structure will always reflect the range [cur_l, cur_r]
    for (Query q : queries) {
        while (cur_l > q.l) {
            cur_l--;
            add(cur_l);
        }
        while (cur_r < q.r) {
            cur_r++;
            add(cur_r);
        }
        while (cur_l < q.l) {
            remove(cur_l);
            cur_l++;
        }
        while (cur_r > q.r) {
            remove(cur_r);
            cur_r--;
        }
        answers[q.idx] = get_answer();
    }
    return answers;
}
```

პრობლემის საფუძველზე შეგვიძლია გამოვიყენოთ მონაცემთა სხვა სტრუქტურა და შესაბამისად შევცვალოთ `add`/`remove`/`get_answer` ფუნქციები.
მაგალითად, თუ გვთხოვენ ვიპოვოთ დიაპაზონის ჯამის მოთხოვნები, მაშინ ჩვენ ვიყენებთ მარტივ მთელ რიცხვს, როგორც მონაცემთა სტრუქტურას, რომელიც არის $0$ დასაწყისში.
"დამატება" ფუნქცია უბრალოდ დაამატებს პოზიციის მნიშვნელობას და შემდგომ განაახლებს პასუხის ცვლადს.
მეორეს მხრივ, "remove" ფუნქცია გამოაკლებს მნიშვნელობას პოზიციაზე და შემდგომ განაახლებს პასუხის ცვლადს.
და `get_answer` უბრალოდ აბრუნებს მთელ რიცხვს.

რეჟიმი-კითხვებზე პასუხის გასაცემად, ჩვენ შეგვიძლია გამოვიყენოთ ორობითი საძიებო ხე (მაგ. `map<int, int>`) შესანახად, თუ რამდენად ხშირად გამოჩნდება თითოეული რიცხვი მიმდინარე დიაპაზონში, და მეორე ორობითი საძიებო ხე (მაგ. `set<pair<int , int>>`) რიცხვების (მაგ., როგორც თვლა-რიცხვის წყვილების) დათვლა თანმიმდევრულად შესანახად.
`დამატების` მეთოდი აშორებს მიმდინარე რიცხვს მეორე BST-დან, ზრდის რიცხვს პირველში და აბრუნებს რიცხვს მეორეში.
"ამოღება" აკეთებს იგივეს, ის მხოლოდ ამცირებს რაოდენობას.
და `get_answer` უბრალოდ უყურებს მეორე ხეს და აბრუნებს საუკეთესო მნიშვნელობას $O(1)$-ში.

### სირთულე

ყველა მოთხოვნის დახარისხებას დასჭირდება $O(Q \log Q)$.

რაც შეეხება სხვა ოპერაციებს?
რამდენჯერ გამოიძახება "დამატება" და "ამოღება"?

ვთქვათ, ბლოკის ზომაა $S$.

თუ ჩვენ შევხედავთ მხოლოდ ყველა მოთხოვნას, რომელსაც აქვს მარცხენა ინდექსი იმავე ბლოკში, მოთხოვნები დალაგებულია მარჯვენა ინდექსის მიხედვით.
ამიტომ ჩვენ დავარქმევთ `add(cur_r)` და `remove(cur_r)` მხოლოდ $O(N)$-ჯერ ყველა ამ შეკითხვის კომბინირებულად.
ეს იძლევა $O(\frac{N}{S} N)$ ზარებს ყველა ბლოკისთვის.

`cur_l`-ის მნიშვნელობა შეიძლება შეიცვალოს მაქსიმუმ $O(S)$-ით ორ მოთხოვნას შორის.
ამიტომ ჩვენ გვაქვს დამატებითი $O(S Q)$ ზარები `add(cur_l)` და `remove(cur_l)`.

$S \დაახლოებით \sqrt{N}$-ისთვის ეს იძლევა $O((N + Q) \sqrt{N})$ ოპერაციებს ჯამში.
ამრიგად, სირთულე არის $O((N+Q)F\sqrt{N})$, სადაც $O(F)$ არის `დამატება` და `ამოღება~ ფუნქციის სირთულე.

### რჩევები გაშვების დროის გასაუმჯობესებლად

* ბლოკის ზომა ზუსტად $\sqrt{N}$ ყოველთვის არ გვთავაზობს მუშაობის საუკეთესო დროს. მაგალითად, თუ $\sqrt{N}=750$, მაშინ შეიძლება მოხდეს, რომ ბლოკის ზომა $700$ ან $800$ უკეთესი იყოს.
რაც მთავარია, არ გამოთვალოთ ბლოკის ზომა გაშვების დროს - გახადეთ ის `const`. მუდმივებზე დაყოფა კარგად არის ოპტიმიზირებული შემდგენელების მიერ.
* კენტ ბლოკებში დაალაგეთ სწორი ინდექსი ზრდადობით, ხოლო ლუწი ბლოკებში კლებადობით. ეს შეამცირებს მარჯვენა მაჩვენებლის მოძრაობას, რადგან ნორმალური დახარისხება გადააადგილებს მარჯვენა მაჩვენებელს ბოლოდან თავში ყოველი ბლოკის დასაწყისში. გაუმჯობესებული ვერსიით ეს გადატვირთვა აღარ არის საჭირო.

```cpp
bool cmp(pair<int, int> p, pair<int, int> q) {
    if (p.first / BLOCK_SIZE != q.first / BLOCK_SIZE)
        return p < q;
    return (p.first / BLOCK_SIZE & 1) ? (p.second < q.second) : (p.second > q.second);
}
```

You can read about even faster sorting approach [here](https://codeforces.com/blog/entry/61203).

## სავარჯიშო

* [Codeforces - Kuriyama Mirai's Stones](https://codeforces.com/problemset/problem/433/B)
* [UVA - 12003 - Array Transformer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3154)
* [UVA - 11990 Dynamic Inversion](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3141)
* [SPOJ - Give Away](http://www.spoj.com/problems/GIVEAWAY/)
* [Codeforces - Till I Collapse](http://codeforces.com/contest/786/problem/C)
* [Codeforces - Destiny](http://codeforces.com/contest/840/problem/D)
* [Codeforces - Holes](http://codeforces.com/contest/13/problem/E)
* [Codeforces - XOR and Favorite Number](https://codeforces.com/problemset/problem/617/E)
* [Codeforces - Powerful array](http://codeforces.com/problemset/problem/86/D)
* [SPOJ - DQUERY](https://www.spoj.com/problems/DQUERY)
