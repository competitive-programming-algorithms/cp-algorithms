# სეგმენტის ხე

სეგმენტის ხე არის მონაცემთა სტრუქტურა, რომელიც ინახავს ინფორმაციას მასივის ინტერვალების შესახებ ხის სახით. ეს საშუალებას იძლევა ეფექტურად უპასუხოს დიაპაზონის შეკითხვებს მასივზე, მაგრამ მაინც საკმარისად მოქნილი იქნება მასივის სწრაფი მოდიფიკაციის დასაშვებად.
ეს მოიცავს $a[l \dots r]$ მასივის თანმიმდევრული ელემენტების ჯამის პოვნას ან ასეთ დიაპაზონში მინიმალური ელემენტის პოვნას $O(\log n)$ დროში.
ასეთ შეკითხვებზე პასუხებს შორის, სეგმენტის ხე იძლევა მასივის შეცვლას ერთი ელემენტის შეცვლით, ან თუნდაც მთელი ქვესეგმენტის ელემენტების შეცვლით (მაგ. $a[l \dots r]$-ის ყველა ელემენტის მინიჭება ნებისმიერ მნიშვნელობაზე, ან ყველასთვის მნიშვნელობის დამატება. ელემენტი ქვესეგმენტში).

ზოგადად, სეგმენტის ხე არის ძალიან მოქნილი მონაცემთა სტრუქტურა და მისი დახმარებით უამრავი პრობლემის მოგვარებაა შესაძლებელი.
გარდა ამისა, ასევე შესაძლებელია უფრო რთული ოპერაციების გამოყენება და უფრო რთულ შეკითხვებზე პასუხის გაცემა (იხ. [სეგმენტის ხეების გაფართოებული ვერსიები](segment_tree.md#advanced-versions-of-segment-trees)).
კერძოდ, სეგმენტის ხე შეიძლება ადვილად განზოგადდეს უფრო დიდ ზომებზე.
მაგალითად, ორგანზომილებიანი სეგმენტის ხის საშუალებით შეგიძლიათ უპასუხოთ ჯამის ან მინიმალურ შეკითხვებს მოცემული მატრიცის ზოგიერთ ქვემართკუთხედზე მხოლოდ $O(\log^2 n)$ დროში.

სეგმენტის ხეების ერთ-ერთი მნიშვნელოვანი თვისება ის არის, რომ მათ სჭირდებათ მეხსიერების მხოლოდ წრფივი რაოდენობა.
სტანდარტული სეგმენტის ხე მოითხოვს $4n$ წვეროებს $n$ ზომის მასივზე მუშაობისთვის.

## სეგმენტის ხის უმარტივესი ფორმა

მარტივი დასაწყებად, ჩვენ განვიხილავთ სეგმენტის ხის უმარტივეს ფორმას.
ჩვენ გვსურს ეფექტურად ვუპასუხოთ თანხის შეკითხვებს.
ჩვენი ამოცანის ოფიციალური განმარტება არის:
$a[0 \dots n-1]$ მასივის გათვალისწინებით, სეგმენტის ხეს უნდა შეეძლოს ელემენტების ჯამის პოვნა $l$ და $r$ ინდექსებს შორის (ანუ $\sum_{i=l} ჯამის გამოთვლა. ^r a[i]$) და ასევე ამუშავებს მასივის ელემენტების მნიშვნელობების შეცვლას (ანუ შეასრულეთ $a[i] = x$ ფორმის დავალებები).
სეგმენტის ხეს უნდა შეეძლოს **ორივე** მოთხოვნის დამუშავება $O(\log n)$ დროში.

ეს არის გაუმჯობესება უფრო მარტივ მიდგომებთან შედარებით.
გულუბრყვილო მასივის განხორციელებას - უბრალოდ მარტივი მასივის გამოყენებით - შეუძლია განაახლოს ელემენტები $O(1)$-ში, მაგრამ მოითხოვს $O(n)$ თითოეული ჯამის მოთხოვნის გამოსათვლელად.
და წინასწარ გამოთვლილ პრეფიქსის ჯამებს შეუძლიათ გამოთვალონ ჯამის მოთხოვნები $O(1)$-ში, მაგრამ მასივის ელემენტის განახლება მოითხოვს $O(n)$ ცვლილებების პრეფიქსის ჯამებს.

### სეგმენტის ხის სტრუქტურა

ჩვენ შეგვიძლია მივიღოთ გაყოფა და იბატონე მიდგომა, როდესაც საქმე ეხება მასივის სეგმენტებს.
ჩვენ ვიანგარიშებთ და ვინახავთ მთელი მასივის ელემენტების ჯამს, ანუ $a[0 \dots n-1]$ სეგმენტის ჯამს.
შემდეგ მასივი გავყოთ ორ ნაწილად $a[0 \dots n/2-1]$ და $a[n/2 \dots n-1]$ და გამოვთვალოთ თითოეული ნახევრის ჯამი და შევინახოთ ისინი.
ამ ორი ნახევრიდან თითოეული თავის მხრივ იყოფა შუაზე და ასე გრძელდება მანამ, სანამ ყველა სეგმენტი არ მიაღწევს $1$-ს ზომას.

ჩვენ შეგვიძლია განვიხილოთ ეს სეგმენტები, როგორც ორობითი ხის ფორმირება:
ამ ხის ფესვი არის სეგმენტი $a[0 \dots n-1]$ და თითოეულ წვეროს (ფოთლის წვეროების გარდა) აქვს ზუსტად ორი შვილობილი წვერო.
ამიტომაც მონაცემთა სტრუქტურას ეწოდება "სეგმენტური ხე", მიუხედავად იმისა, რომ უმეტეს დანერგვაში ხე არ არის აგებული აშკარად (იხ. [Implementation](segment_tree.md#implementation)).

აქ არის ასეთი სეგმენტის ხის ვიზუალური წარმოდგენა $a = [1, 3, -2, 8, -7]$ მასივზე:

!["ჯამური სეგმენტის ხე"](sum-segment-tree.png)

მონაცემთა სტრუქტურის ამ მოკლე აღწერიდან უკვე შეგვიძლია დავასკვნათ, რომ სეგმენტური ხე მოითხოვს მხოლოდ წვეროების წრფივ რაოდენობას.
ხის პირველი დონე შეიცავს ერთ კვანძს (ძირს), მეორე დონე შეიცავს ორ წვეროს, მესამეში შეიცავს ოთხ წვეროს, სანამ წვეროების რაოდენობა არ მიაღწევს $n$-ს.
ამრიგად, წვეროების რაოდენობა უარეს შემთხვევაში შეიძლება შეფასდეს ჯამით $1 + 2 + 4 + \წერტილები + 2^{\lceil\log_2 n\rceil} \lt 2^{\lceil\log_2 n\rceil + 1} \lt 4n$.

აღსანიშნავია, რომ როდესაც $n$ არ არის ორის სიმძლავრე, სეგმენტის ხის ყველა დონე სრულად არ შეივსება.
ჩვენ შეგვიძლია დავინახოთ ეს ქცევა სურათზე.
ჯერ-ჯერობით შეგვიძლია დავივიწყოთ ეს ფაქტი, მაგრამ ეს მნიშვნელოვანი გახდება მოგვიანებით განხორციელების დროს.

სეგმენტის ხის სიმაღლეა $O(\log n)$, რადგან ფესვიდან ფოთლებზე დაშვებისას სეგმენტების ზომა მცირდება დაახლოებით ნახევარით.

### მშენებლობა

სეგმენტის ხის აშენებამდე უნდა გადავწყვიტოთ:

1. *მნიშვნელობა*, რომელიც ინახება სეგმენტის ხის თითოეულ კვანძში.
   მაგალითად, ჯამის სეგმენტის ხეში, კვანძი ინახავს ელემენტების ჯამს მის დიაპაზონში $[l, r]$.
2. *merge* ოპერაცია, რომელიც აერთიანებს ორ ძმას სეგმენტის ხეში.
   მაგალითად, ჯამის სეგმენტის ხეში, $a[l_1 \dots r_1]$ და $a[l_2 \dots r_2]$ დიაპაზონის შესაბამისი ორი კვანძი გაერთიანდება $a[l_1 \" დიაპაზონის შესაბამის კვანძში. წერტილები r_2]$ ორი კვანძის მნიშვნელობების დამატებით.

გაითვალისწინეთ, რომ წვერო არის "ფოთლის წვერო", თუ მისი შესაბამისი სეგმენტი მოიცავს მხოლოდ ერთ მნიშვნელობას თავდაპირველ მასივში. ის იმყოფება სეგმენტის ხის ყველაზე ქვედა დონეზე. მისი მნიშვნელობა ტოლი იქნება (შესაბამისი) ელემენტის $a[i]$.

ახლა, სეგმენტის ხის ასაგებად, ვიწყებთ ქვედა დონიდან (ფოთლის წვეროები) და მივანიჭებთ მათ შესაბამის მნიშვნელობებს. ამ მნიშვნელობების საფუძველზე ჩვენ შეგვიძლია გამოვთვალოთ წინა დონის მნიშვნელობები `შერწყმის` ფუნქციის გამოყენებით.
და მათ საფუძველზე შეგვიძლია გამოვთვალოთ წინა მნიშვნელობები და გავიმეოროთ პროცედურა მანამ, სანამ არ მივაღწევთ ფესვის წვეროს.

მოსახერხებელია ამ ოპერაციის რეკურსიულად აღწერა სხვა მიმართულებით, ანუ ფესვის წვეროდან ფოთლის წვეროებამდე. კონსტრუქციის პროცედურა, თუ მოწოდებულია არაფოთლოვან წვეროზე, აკეთებს შემდეგს:

1. რეკურსიულად ააგეთ ორი შვილის წვეროების მნიშვნელობები
2. ამ ბავშვების გამოთვლილი მნიშვნელობების შერწყმა.

ჩვენ ვიწყებთ მშენებლობას ფესვის წვეროზე და, შესაბამისად, შეგვიძლია გამოვთვალოთ მთელი სეგმენტის ხე.

ამ კონსტრუქციის დროის სირთულეა $O(n)$, თუ ვივარაუდებთ, რომ შერწყმის ოპერაცია არის მუდმივი დრო (შერწყმის ოპერაციას ეძახიან $n$ ჯერ, რაც უდრის სეგმენტის ხეში შიდა კვანძების რაოდენობას).

### ჯამური მოთხოვნები

ახლა ვაპირებთ ვუპასუხოთ თანხის შეკითხვებს. შეყვანის სახით ვიღებთ ორ მთელ რიცხვს $l$ და $r$ და უნდა გამოვთვალოთ $a[l \dots r]$ სეგმენტის ჯამი $O(\log n)$ დროში.

ამისათვის ჩვენ გადავხედავთ სეგმენტის ხეს და გამოვიყენებთ სეგმენტების წინასწარ გამოთვლილ ჯამებს.
დავუშვათ, რომ ამჟამად ვართ წვეროზე, რომელიც ფარავს სეგმენტს $a[tl \dots tr]$.
არსებობს სამი შესაძლო შემთხვევა.

უმარტივესი შემთხვევაა, როდესაც სეგმენტი $a[l \dots r]$ უდრის მიმდინარე წვერის შესაბამის სეგმენტს (ანუ $a[l \dots r] = a[tl \dots tr]$), მაშინ ჩვენ ვართ დასრულდა და შეუძლია დააბრუნოს წინასწარ გამოთვლილი ჯამი, რომელიც ინახება წვეროში.

ალტერნატიულად, მოთხოვნის სეგმენტი შეიძლება მთლიანად მოხვდეს მარცხენა ან მარჯვენა ბავშვის დომენში.
შეგახსენებთ, რომ მარცხენა ბავშვი ფარავს სეგმენტს $a[tl \dots tm]$ და მარჯვენა წვერო ფარავს სეგმენტს $a[tm + 1 \dots tr]$ $tm = (tl + tr) / 2$.
ამ შემთხვევაში ჩვენ შეგვიძლია უბრალოდ გადავიდეთ ბავშვის წვეროზე, რომელიც შესაბამისი სეგმენტი ფარავს მოთხოვნის სეგმენტს და ამ წვერით შევასრულოთ აქ აღწერილი ალგორითმი.

და შემდეგ არის ბოლო შემთხვევა, შეკითხვის სეგმენტი კვეთს ორივე ბავშვს.
ამ შემთხვევაში ჩვენ არ გვაქვს სხვა საშუალება, რომ განვახორციელოთ ორი რეკურსიული ზარი, თითო თითოეული ბავშვისთვის.
ჯერ მივდივართ მარცხენა შვილზე, ვიანგარიშებთ ნაწილობრივ პასუხს ამ წვეროზე (ანუ მოთხოვნის სეგმენტსა და მარცხენა ბავშვის სეგმენტს შორის გადაკვეთის მნიშვნელობების ჯამი), შემდეგ გადავდივართ მარჯვენა შვილზე, გამოვთვალეთ ნაწილობრივი პასუხი. ამ წვეროს გამოყენებით და შემდეგ დააკავშირეთ პასუხები მათი დამატებით.
სხვა სიტყვებით რომ ვთქვათ, რადგან მარცხენა ბავშვი წარმოადგენს $a[tl \dots tm]$ სეგმენტს და მარჯვენა შვილი სეგმენტს $a[tm+1 \dots tr]$, ჩვენ გამოვთვალეთ ჯამის მოთხოვნა $a[l \dots tm. ]$ მარცხენა ბავშვის გამოყენებით და ჯამის მოთხოვნა $a[tm+1 \dots r]$ მარჯვენა ბავშვის გამოყენებით.

მაშ ასე, ჯამის მოთხოვნის დამუშავება არის ფუნქცია, რომელიც რეკურსიულად იძახებს საკუთარ თავს ერთხელ ან მარცხენა ან მარჯვენა შვილით (შეკითხვის საზღვრების შეცვლის გარეშე), ან ორჯერ, ერთხელ მარცხენა და ერთხელ მარჯვენა ბავშვისთვის (მოთხოვნის ორ ქვემოთხოვნაზე დაყოფით. ).
და რეკურსია მთავრდება, როდესაც მიმდინარე მოთხოვნის სეგმენტის საზღვრები ემთხვევა მიმდინარე წვეროს სეგმენტის საზღვრებს.
ამ შემთხვევაში პასუხი იქნება ამ სეგმენტის ჯამის წინასწარ გამოთვლილი მნიშვნელობა, რომელიც ინახება ხეში.

სხვა სიტყვებით რომ ვთქვათ, მოთხოვნის გაანგარიშება არის ხის გადაკვეთა, რომელიც ვრცელდება ხის ყველა საჭირო ტოტზე და იყენებს ხეში სეგმენტების წინასწარ გამოთვლილ ჯამურ მნიშვნელობებს.

ცხადია, ჩვენ დავიწყებთ გადაკვეთას სეგმენტის ხის ძირეული წვეროდან.

პროცედურა ილუსტრირებულია შემდეგ სურათზე.
ისევ გამოიყენება მასივი $a = [1, 3, -2, 8, -7]$ და აქ გვინდა გამოვთვალოთ $\sum_{i=2}^4 a[i]$ ჯამი.
ფერადი წვეროები მოვინახულებთ და ჩვენ გამოვიყენებთ მწვანე წვეროების წინასწარ გამოთვლილ მნიშვნელობებს.
ეს გვაძლევს შედეგს $-2 + 1 = -1$.

!["Sum Segment Tree Query"](sum-segment-tree-query.png)

რატომ არის ამ ალგორითმის სირთულე $O(\log n)$?
ამ სირთულის საჩვენებლად ჩვენ ვუყურებთ ხის თითოეულ დონეს.
გამოდის, რომ თითოეული დონისთვის ჩვენ მხოლოდ ვეწვევით არაუმეტეს ოთხი წვეროს.
და რადგან ხის სიმაღლეა $O(\log n)$, ჩვენ ვიღებთ სასურველ გაშვების დროს.

ჩვენ შეგვიძლია ვაჩვენოთ, რომ ეს წინადადება (ყველა დონეზე მაქსიმუმ ოთხი წვერო) ჭეშმარიტია ინდუქციით.
პირველ დონეზე ჩვენ ვსტუმრობთ მხოლოდ ერთ წვეროს, ფესვის წვეროს, ასე რომ, აქ ვსტუმრობთ ოთხზე ნაკლებ წვეროს.
ახლა მოდით შევხედოთ თვითნებურ დონეს.
ინდუქციური ჰიპოთეზის მიხედვით, ჩვენ ვსტუმრობთ მაქსიმუმ ოთხ წვეროს.
თუ ჩვენ ვეწვევით მაქსიმუმ ორ წვეროს, შემდეგ დონეს აქვს მაქსიმუმ ოთხი წვერო. ეს ტრივიალურია, რადგან თითოეულ წვეროს შეუძლია გამოიწვიოს მაქსიმუმ ორი რეკურსიული ზარი.
ასე რომ, დავუშვათ, რომ ჩვენ ვეწვევით სამ ან ოთხ წვეროს მიმდინარე დონეზე.
ამ წვეროებიდან ჩვენ უფრო ყურადღებით გავაანალიზებთ შუა წვეროებს.
ვინაიდან ჯამის მოთხოვნა ითხოვს უწყვეტი ქვემაივის ჯამს, ვიცით, რომ შუაში მონახულებული წვეროების შესაბამისი სეგმენტები მთლიანად დაფარული იქნება ჯამის მოთხოვნის სეგმენტით.
ამიტომ ეს წვეროები არ განახორციელებენ რეკურსიულ ზარებს.
ასე რომ, მხოლოდ ყველაზე მარცხნივ და ყველაზე მარჯვენა წვეროს ექნება რეკურსიული ზარების განხორციელების პოტენციალი.
და ეს მხოლოდ მაქსიმუმ ოთხ რეკურსიულ ზარს შექმნის, ასე რომ, შემდეგი დონეც დააკმაყოფილებს მტკიცებას.
შეგვიძლია ვთქვათ, რომ ერთი ტოტი უახლოვდება მოთხოვნის მარცხენა საზღვარს, ხოლო მეორე ტოტი უახლოვდება მარჯვენას.

აქედან გამომდინარე, ჩვენ ვეწვევით მაქსიმუმ $4 ​​\log n$ წვეროებს, რაც უდრის $O(\log n)$-ის გაშვების დროს.

დასკვნის სახით, შეკითხვა მუშაობს შეყვანის სეგმენტის რამდენიმე ქვესეგმენტად დაყოფით, რომლისთვისაც ყველა ჯამი უკვე წინასწარ არის გამოთვლილი და ინახება ხეში.
და თუ ჩვენ შევწყვეტთ დაყოფას, როდესაც მოთხოვნის სეგმენტი ემთხვევა წვერის სეგმენტს, მაშინ ჩვენ გვჭირდება მხოლოდ $O(\log n)$ ასეთი სეგმენტები, რაც იძლევა სეგმენტის ხის ეფექტურობას.

### განაახლეთ მოთხოვნები

ახლა ჩვენ გვინდა შევცვალოთ კონკრეტული ელემენტი მასივში, ვთქვათ, გვინდა გავაკეთოთ დავალება $a[i] = x$.
და ჩვენ უნდა აღვადგინოთ სეგმენტის ხე ისე, რომ იგი შეესაბამებოდეს ახალ, შეცვლილ მასივს.

ეს შეკითხვა უფრო ადვილია, ვიდრე ჯამის მოთხოვნა.
სეგმენტის ხის თითოეული დონე ქმნის მასივის დანაყოფს.
ამიტომ ელემენტი $a[i]$ მხოლოდ ერთ სეგმენტში მონაწილეობს თითოეული დონიდან.
ამრიგად, მხოლოდ $O(\log n)$ წვეროების განახლებაა საჭირო.

ადვილი მისახვედრია, რომ განახლების მოთხოვნა შეიძლება განხორციელდეს რეკურსიული ფუნქციის გამოყენებით.
ფუნქციას გადაეცემა მიმდინარე ხის წვერო და ის რეკურსიულად უწოდებს საკუთარ თავს ორი შვილობილი წვეროდან ერთ-ერთს (ის, რომელიც შეიცავს $a[i]$-ს თავის სეგმენტში) და ამის შემდეგ ხელახლა ითვლის მის ჯამურ მნიშვნელობას, ანალოგიურად როგორ ხდება ეს. აშენების მეთოდში (ეს არის მისი ორი შვილის ჯამი).

ისევ აქ არის ვიზუალიზაცია იმავე მასივის გამოყენებით.
აქ ჩვენ ვასრულებთ განახლებას $a[2] = 3$.
მწვანე წვეროები არის წვეროები, რომლებსაც ჩვენ ვეწვევით და ვაახლებთ.

!["Sum Segment Tree Update"](sum-segment-tree-update.png)

### განხორციელება

მთავარი მოსაზრებაა, თუ როგორ უნდა შეინახოთ სეგმენტის ხე.
რა თქმა უნდა, ჩვენ შეგვიძლია განვსაზღვროთ $\text{Vertex}$-ის სტრუქტურა და შევქმნათ ობიექტები, რომლებიც ინახავს სეგმენტის საზღვრებს, მის ჯამს და დამატებით ასევე მიუთითებს მის შვილობილ წვეროებზე.
თუმცა, ეს მოითხოვს ბევრი ზედმეტი ინფორმაციის შენახვას პოინტერების სახით.
ჩვენ გამოვიყენებთ მარტივ ხრიკს, რომ ეს ბევრად უფრო ეფექტური გავხადოთ _ იმპლიციტური მონაცემთა სტრუქტურის გამოყენებით: მხოლოდ ჯამების შენახვა მასივში.
(მსგავსი მეთოდი გამოიყენება ორობითი გროვებისთვის).
ძირის წვეროების ჯამი 1 ინდექსზე, მისი ორი შვილის წვეროების ჯამები 2 და 3 ინდექსებზე, ამ ორი წვერის შვილების ჯამი 4-დან 7-მდე ინდექსებზე და ა.შ.
1-ინდექსაციით, მოხერხებულად წვერის მარცხენა შვილი $i$ ინდექსზე ინახება $2i$ ინდექსზე, ხოლო მარჯვენა ინდექსზე $2i + 1$.
ექვივალენტურად, $i$ ინდექსში წვეროს მშობელი ინახება $i/2$-ზე (მთლიანი გაყოფა).

ეს ძალიან ამარტივებს განხორციელებას.
ჩვენ არ გვჭირდება ხის სტრუქტურის მეხსიერებაში შენახვა.
ის ირიბად არის განსაზღვრული.
ჩვენ გვჭირდება მხოლოდ ერთი მასივი, რომელიც შეიცავს ყველა სეგმენტის ჯამს.

როგორც უკვე აღვნიშნეთ, ჩვენ უნდა შევინახოთ მაქსიმუმ $4n$ წვეროები.
ეს შეიძლება იყოს ნაკლები, მაგრამ მოხერხებულობისთვის ჩვენ ყოველთვის გამოვყოფთ $4n$ ზომის მასივს.
იქნება რამდენიმე ელემენტი ჯამების მასივში, რომლებიც არ შეესაბამებიან ფაქტობრივ ხეში არსებულ რომელიმე წვეროს, მაგრამ ეს არ ართულებს განხორციელებას.

ასე რომ, ჩვენ ვინახავთ სეგმენტის ხეს უბრალოდ $t[]$ მასივის სახით, რომლის ზომა ოთხჯერ აღემატება შეყვანის ზომას $n$:

```{.cpp file=segment_tree_implementation_definition}
int n, t[4*MAXN];
```

სეგმენტის ხის აგების პროცედურა მოცემული მასივიდან $a[]$ ასე გამოიყურება:
ეს არის რეკურსიული ფუნქცია პარამეტრებით $a[]$ (შეყვანის მასივი), $v$ (მიმდინარე წვეროს ინდექსი) და მიმდინარე სეგმენტის $tl$ და $tr$ საზღვრებით.
მთავარ პროგრამაში ეს ფუნქცია გამოიძახება ძირეული წვერის პარამეტრებით: $v = 1$, $tl = 0$ და $tr = n - 1$.

```{.cpp file=segment_tree_implementation_build}
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = t[v*2] + t[v*2+1];
    }
}
```

გარდა ამისა, ჯამების შეკითხვებზე პასუხის ფუნქცია ასევე არის რეკურსიული ფუნქცია, რომელიც პარამეტრებად იღებს ინფორმაციას მიმდინარე წვეროზე/სეგმენტზე (ანუ ინდექსი $v$ და $tl$ და $tr$ საზღვრები) და ასევე ინფორმაციას საზღვრების შესახებ. შეკითხვა, $l$ და $r$.
კოდის გამარტივების მიზნით, ეს ფუნქცია ყოველთვის აკეთებს ორ რეკურსიულ ზარს, თუნდაც მხოლოდ ერთი იყოს საჭირო - ამ შემთხვევაში ზედმეტ რეკურსიულ ზარს ექნება $l > r$, და ამის დაფიქსირება შესაძლებელია დასაწყისში დამატებითი შემოწმების გამოყენებით. ფუნქციის.

```{.cpp file=segment_tree_implementation_sum}
int sum(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return 0;
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return sum(v*2, tl, tm, l, min(r, tm))
           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
}
```

საბოლოოდ განახლების მოთხოვნა. ფუნქცია ასევე მიიღებს ინფორმაციას მიმდინარე წვეროზე/სეგმენტზე და დამატებით ასევე განახლების მოთხოვნის პარამეტრს (ანუ ელემენტის პოზიციას და მის ახალ მნიშვნელობას).

```{.cpp file=segment_tree_implementation_update}
void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}
```

### მეხსიერების ეფექტური განხორციელება

ადამიანების უმეტესობა იყენებს წინა განყოფილების განხორციელებას. თუ დააკვირდებით `t` მასივს, ხედავთ, რომ ის მიჰყვება ხის კვანძების ნუმერაციას BFS გადაკვეთის თანმიმდევრობით (დონის რიგის გადაკვეთა).
ამ გადაკვეთის გამოყენებით $v$ წვერის შვილები არიან $2v$ და $2v + 1$, შესაბამისად.
თუმცა, თუ $n$ არ არის ორის სიმძლავრე, ეს მეთოდი გამოტოვებს ზოგიერთ ინდექსს და გამოუყენებელს დატოვებს `t` მასივის ზოგიერთ ნაწილს.
მეხსიერების მოხმარება შეზღუდულია $4n$-ით, მიუხედავად იმისა, რომ $n$ ელემენტების მასივის სეგმენტური ხე მოითხოვს მხოლოდ $2n - 1$ წვეროებს.

თუმცა შეიძლება შემცირდეს.
ხის წვეროებს ხელახლა ვნომრავთ ეილერის ტურის (წინასწარ შეკვეთის გადაკვეთის) თანმიმდევრობით და ყველა ამ წვეროს ვწერთ ერთმანეთის გვერდით.

მოდით შევხედოთ წვეროს $v$ ინდექსზე და მოდით, ის იყოს პასუხისმგებელი $[l, r]$ სეგმენტზე და მოდით $mid = \dfrac{l + r}{2}$.
აშკარაა, რომ მარცხენა შვილს ექნება ინდექსი $v + 1$.
მარცხენა ბავშვი პასუხისმგებელია $[l, mid]$ სეგმენტზე, ანუ მთლიანობაში იქნება $2 * (შუა - l + 1) - 1$ წვეროები მარცხენა ბავშვის ქვეხეში.
ამრიგად, ჩვენ შეგვიძლია გამოვთვალოთ $v$-ის მარჯვენა შვილის ინდექსი. ინდექსი იქნება $v + 2 * (შუა - l + 1)$.
ამ ნუმერაციით მივაღწევთ საჭირო მეხსიერების შემცირებას $2n$-მდე.

## <a name="advanced-versions-of-segment-trees"></a>სეგმენტის ხეების გაფართოებული ვერსიები


სეგმენტის ხე არის ძალიან მოქნილი მონაცემთა სტრუქტურა და იძლევა ვარიაციებს და გაფართოებებს სხვადასხვა მიმართულებით.
შევეცადოთ დავახარისხოთ ისინი ქვემოთ.

### უფრო რთული მოთხოვნები

შეიძლება საკმაოდ მარტივი იყოს სეგმენტის ხის შეცვლა ისეთი მიმართულებით, რომ იგი გამოთვლის სხვადასხვა მოთხოვნას (მაგ. მინიმალური/მაქსიმუმის გამოთვლა ჯამის ნაცვლად), მაგრამ ასევე შეიძლება იყოს ძალიან არატრივიალური.

#### მაქსიმუმის პოვნა

მოდით, ოდნავ შევცვალოთ ზემოთ აღწერილი პრობლემის მდგომარეობა: თანხის მოთხოვნის ნაცვლად, ახლა მაქსიმალურ მოთხოვნას გავაკეთებთ.

ხეს ექნება ზუსტად იგივე სტრუქტურა, როგორც ზემოთ აღწერილი ხე.
ჩვენ მხოლოდ $t[v]$-ის გამოთვლის წესი უნდა შევცვალოთ $\text{build}$ და $\text{update}$ ფუნქციებში.
$t[v]$ ახლა შეინახავს შესაბამისი სეგმენტის მაქსიმუმს.
და ჩვენ ასევე უნდა შევცვალოთ $\text{sum}$ ფუნქციის დაბრუნებული მნიშვნელობის გაანგარიშება (შეჯამების ჩანაცვლება მაქსიმუმით).

რა თქმა უნდა, ეს პრობლემა შეიძლება ადვილად შეიცვალოს მაქსიმუმის ნაცვლად მინიმუმის გამოთვლაში.

ამ პრობლემის განხორციელების ჩვენების ნაცვლად, იმპლემენტაცია გადაეცემა ამ პრობლემის უფრო რთულ ვერსიას შემდეგ განყოფილებაში.

#### იპოვნეთ მაქსიმუმი და რამდენჯერ გამოჩნდება

ეს ამოცანა ძალიან ჰგავს წინა.
მაქსიმუმის პოვნის გარდა, ჩვენ ასევე უნდა ვიპოვოთ მაქსიმუმის შემთხვევების რაოდენობა.

ამ პრობლემის გადასაჭრელად, ჩვენ ვინახავთ რიცხვების წყვილს ხეში თითოეულ წვეროზე:
გარდა მაქსიმუმისა, ჩვენ ასევე ვინახავთ მის შემთხვევების რაოდენობას შესაბამის სეგმენტში.
სწორი წყვილის დადგენა $t[v]$-ზე შესანახად მაინც შეიძლება განხორციელდეს მუდმივ დროში წყვილების ინფორმაციის გამოყენებით, რომლებიც ინახება შვილო წვეროებზე.
ორი ასეთი წყვილის გაერთიანება უნდა განხორციელდეს ცალკე ფუნქციაში, რადგან ეს იქნება ოპერაცია, რომელსაც ჩვენ გავაკეთებთ ხის აშენებისას, მაქსიმალურ შეკითხვებზე პასუხის გაცემისას და ცვლილებების შესრულებისას.

```{.cpp file=segment_tree_maximum_and_count}
pair<int, int> t[4*MAXN];

pair<int, int> combine(pair<int, int> a, pair<int, int> b) {
    if (a.first > b.first) 
        return a;
    if (b.first > a.first)
        return b;
    return make_pair(a.first, a.second + b.second);
}

void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = make_pair(a[tl], 1);
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = combine(t[v*2], t[v*2+1]);
    }
}

pair<int, int> get_max(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return make_pair(-INF, 0);
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return combine(get_max(v*2, tl, tm, l, min(r, tm)), 
                   get_max(v*2+1, tm+1, tr, max(l, tm+1), r));
}

void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = make_pair(new_val, 1);
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = combine(t[v*2], t[v*2+1]);
    }
}
```
#### გამოთვალეთ უდიდესი საერთო გამყოფი / უმცირესი საერთო ჯერადი

ამ პრობლემაში ჩვენ გვინდა გამოვთვალოთ GCD/LCM მასივის მოცემული დიაპაზონების ყველა რიცხვის.

სეგმენტის ხის ეს საინტერესო ვარიაცია შეიძლება გადაიჭრას ზუსტად ისევე, როგორც სეგმენტის ხეები, რომლებიც ჩვენ გამოვიყვანეთ ჯამის / მინიმალური / მაქსიმალური მოთხოვნებისთვის:
საკმარისია შევინახოთ შესაბამისი წვეროს GCD / LCM ხის თითოეულ წვეროში.
ორი წვერის გაერთიანება შეიძლება განხორციელდეს ორივე წვეროს GCD/LCM-ის გამოთვლით.

#### ნულების რიცხვის დათვლა, $k$-th ნულის ძიება { #counting-zero-search-kth data-toc-label="ნულების რაოდენობის დათვლა, k-th ნულის ძიება"}

ამ პრობლემაში გვინდა ვიპოვოთ ნულების რაოდენობა მოცემულ დიაპაზონში და დამატებით ვიპოვოთ $k$-th ნულის ინდექსი მეორე ფუნქციის გამოყენებით.

კვლავ ცოტა უნდა შევცვალოთ ხის შენახვის მნიშვნელობები:
ამჯერად ჩვენ შევინახავთ ნულების რაოდენობას თითოეულ სეგმენტში $t[]$-ში.
საკმაოდ გასაგებია, როგორ განვახორციელოთ $\text{build}$, $\text{update}$ და $\text{count_zero}$ ფუნქციები, ჩვენ უბრალოდ შეგვიძლია გამოვიყენოთ იდეები ჯამის შეკითხვის პრობლემისგან.
ამრიგად, ჩვენ გადავწყვიტეთ პრობლემის პირველი ნაწილი.

ახლა ჩვენ ვისწავლით, როგორ გადავჭრათ $a[]$ მასივში $k$-th ნულის პოვნის პრობლემა.
ამ ამოცანის შესასრულებლად, ჩვენ ჩამოვალთ სეგმენტის ხეზე, დაწყებული ძირის წვეროდან და ყოველ ჯერზე გადავალთ მარცხენა ან მარჯვენა შვილზე, იმისდა მიხედვით, თუ რომელი სეგმენტი შეიცავს $k$-th ნულს.
იმისათვის, რომ გადავწყვიტოთ რომელ ბავშვთან უნდა მივიდეთ, საკმარისია გადავხედოთ მარცხენა წვეროს შესაბამის სეგმენტში გამოჩენილ ნულების რაოდენობას.
თუ ეს წინასწარ გამოთვლილი რაოდენობა მეტია ან $k$-ის ტოლია, აუცილებელია ჩამოსვლა მარცხენა ბავშვზე და სხვაგვარად დაშვება მარჯვენა შვილზე.
ყურადღება მიაქციეთ, თუ ჩვენ ავირჩიეთ სწორი შვილი, უნდა გამოვაკლოთ მარცხენა ბავშვის ნულების რაოდენობა $k$-ს.

განხორციელებისას ჩვენ შეგვიძლია გავუმკლავდეთ სპეციალურ შემთხვევას, $a[]$, რომელიც შეიცავს $k$-ზე ნაკლებ ნულს, -1-ის დაბრუნებით.

```{.cpp file=segment_tree_kth_zero}
int find_kth(int v, int tl, int tr, int k) {
    if (k > t[v])
        return -1;
    if (tl == tr)
        return tl;
    int tm = (tl + tr) / 2;
    if (t[v*2] >= k)
        return find_kth(v*2, tl, tm, k);
    else 
        return find_kth(v*2+1, tm+1, tr, k - t[v*2]);
}
```

#### მასივის პრეფიქსის ძიება მოცემული რაოდენობით

დავალება ასეთია:
მოცემული მნიშვნელობისთვის $x$ სწრაფად უნდა ვიპოვოთ $i$-ის უმცირესი ინდექსი, რომ $a[]$ მასივის პირველი $i$ ელემენტების ჯამი იყოს $x$-ის დიდი ან ტოლი (დავარაუდეთ, რომ მასივი $ a[]$ შეიცავს მხოლოდ არაუარყოფით მნიშვნელობებს).

ამ ამოცანის ამოხსნა შესაძლებელია ორობითი ძიების გამოყენებით, პრეფიქსების ჯამის გამოთვლა სეგმენტის ხესთან.
თუმცა ეს გამოიწვევს $O(\log^2 n)$ გადაწყვეტას.

ამის ნაცვლად, ჩვენ შეგვიძლია გამოვიყენოთ იგივე იდეა, როგორც წინა განყოფილებაში და ვიპოვოთ პოზიცია ხეზე დაშვებით:
ყოველ ჯერზე მარცხნივ ან მარჯვნივ გადაადგილებით, მარცხენა ბავშვის ჯამიდან გამომდინარე.
ამგვარად პასუხის პოვნა $O(\log n)$ დროში.

#### მოცემულ რაოდენობაზე მეტი პირველი ელემენტის ძიება

დავალება ასეთია:
$x$ მოცემული მნიშვნელობისთვის და $a[l \dots r]$ დიაპაზონისთვის იპოვეთ უმცირესი $i$ $a[l \dots r]$ დიაპაზონში, ისეთი, რომ $a[i]$ მეტია $-ზე x$.

ამ ამოცანის გადაჭრა შესაძლებელია ორობითი ძიების გამოყენებით მაქსიმალურ პრეფიქსის შეკითხვებზე სეგმენტის ხის საშუალებით.
თუმცა, ეს გამოიწვევს $O(\log^2 n)$ გადაწყვეტას.

ამის ნაცვლად, ჩვენ შეგვიძლია გამოვიყენოთ იგივე იდეა, როგორც წინა სექციებში და ვიპოვოთ პოზიცია ხეზე დაშვებით:
ყოველ ჯერზე მარცხნივ ან მარჯვნივ გადაადგილებით, მარცხენა ბავშვის მაქსიმალური მნიშვნელობიდან გამომდინარე.
ამგვარად პასუხის პოვნა $O(\log n)$ დროში.

```{.cpp file=segment_tree_first_greater}
int get_first(int v, int tl, int tr, int l, int r, int x) {
    if(tl > r || tr < l) return -1;
    if(t[v] <= x) return -1;
    
    if (tl== tr) return tl;
    
    int tm = tl + (tr-tl)/2;
    int left = get_first(2*v, tl, tm, l, r, x);
    if(left != -1) return left;
    return get_first(2*v+1, tm+1, tr, l ,r, x);
}
```

#### ქვესეგმენტების პოვნა მაქსიმალური ჯამით

აქ კვლავ ვიღებთ $a[l \dots r]$ დიაპაზონს თითოეული მოთხოვნისთვის, ამჯერად ჩვენ უნდა ვიპოვოთ $a[l^\prime \dots r^\prime]$ ქვესეგმენტი, რომ $l \le l^ \prime$ და $r^\prime \le r$ და ამ სეგმენტის ელემენტების ჯამი მაქსიმალურია.
როგორც ადრე, ჩვენ ასევე გვსურს შეგვეძლოს მასივის ცალკეული ელემენტების შეცვლა.
მასივის ელემენტები შეიძლება იყოს უარყოფითი, ხოლო ოპტიმალური ქვესეგმენტი შეიძლება იყოს ცარიელი (მაგ. თუ ყველა ელემენტი უარყოფითია).

ეს პრობლემა არის სეგმენტური ხის არატრივიალური გამოყენება.
ამჯერად ჩვენ შევინახავთ ოთხ მნიშვნელობას თითოეული წვეროსთვის:
სეგმენტის ჯამი, მაქსიმალური პრეფიქსი ჯამი, მაქსიმალური სუფიქსი ჯამი და მასში არსებული მაქსიმალური ქვესეგმენტის ჯამი.
სხვა სიტყვებით რომ ვთქვათ, სეგმენტის ხის თითოეული სეგმენტისთვის პასუხი უკვე წინასწარ არის გამოთვლილი, ისევე როგორც პასუხები სეგმენტებისთვის, რომლებიც ეხება სეგმენტის მარცხენა და მარჯვენა საზღვრებს.

როგორ ავაშენოთ ხე ასეთი მონაცემებით?
ჩვენ კვლავ ვიანგარიშებთ მას რეკურსიული გზით:
ჩვენ ჯერ გამოვთვლით ოთხივე მნიშვნელობას მარცხენა და მარჯვენა ბავშვისთვის და შემდეგ გავაერთიანებთ მათ ოთხივე მნიშვნელობის დაარქივებისთვის მიმდინარე წვეროსთვის.
გაითვალისწინეთ პასუხი მიმდინარე წვეროზე არის:

 * მარცხენა ბავშვის პასუხი, რაც ნიშნავს, რომ ოპტიმალური ქვესეგმენტი მთლიანად მოთავსებულია მარცხენა ბავშვის სეგმენტში
 * სწორი ბავშვის პასუხი, რაც ნიშნავს, რომ ოპტიმალური ქვესეგმენტი მთლიანად მოთავსებულია სწორი ბავშვის სეგმენტში
 * მარცხენა ბავშვის მაქსიმალური სუფიქსის ჯამის და მარჯვენა შვილის მაქსიმალური პრეფიქსის ჯამის ჯამი, რაც ნიშნავს, რომ ოპტიმალური ქვესეგმენტი იკვეთება ორივე შვილთან.

აქედან გამომდინარე, პასუხი მიმდინარე წვეროზე არის ამ სამი მნიშვნელობის მაქსიმუმი.
მაქსიმალური პრეფიქსის / სუფიქსის ჯამის გამოთვლა კიდევ უფრო ადვილია.
აქ არის $\text{combine}$ ფუნქციის განხორციელება, რომელიც იღებს მხოლოდ მონაცემებს მარცხენა და მარჯვენა ბავშვისგან და აბრუნებს მიმდინარე წვეროს მონაცემებს.

```{.cpp file=segment_tree_maximal_sum_subsegments1}
struct data {
    int sum, pref, suff, ans;
};

data combine(data l, data r) {
    data res;
    res.sum = l.sum + r.sum;
    res.pref = max(l.pref, l.sum + r.pref);
    res.suff = max(r.suff, r.sum + l.suff);
    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);
    return res;
}
```

$\text{combine}$ ფუნქციის გამოყენებით ადვილია სეგმენტის ხის აგება.
ჩვენ შეგვიძლია მისი განხორციელება ზუსტად ისე, როგორც წინა დანერგვაში.
ფოთლის წვეროების ინიციალიზაციისთვის ჩვენ დამატებით ვქმნით დამხმარე ფუნქციას $\text{make_data}$, რომელიც დააბრუნებს $\text{data}$ ობიექტს, რომელიც შეიცავს ერთი მნიშვნელობის ინფორმაციას.

```{.cpp file=segment_tree_maximal_sum_subsegments2}
data make_data(int val) {
    data res;
    res.sum = val;
    res.pref = res.suff = res.ans = max(0, val);
    return res;
}

void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = make_data(a[tl]);
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = combine(t[v*2], t[v*2+1]);
    }
}
 
void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = make_data(new_val);
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = combine(t[v*2], t[v*2+1]);
    }
}
```

რჩება მხოლოდ ის, თუ როგორ გამოვთვალოთ პასუხი შეკითხვაზე.
მასზე პასუხის გასაცემად, ჩვენ ჩავდივართ ხეზე, როგორც ადრე, ვყოფთ შეკითხვას რამდენიმე ქვესეგმენტად, რომლებიც ემთხვევა სეგმენტის ხის სეგმენტებს და ვაერთებთ მათში მოცემულ პასუხებს მოთხოვნის ერთ პასუხში.
მაშინ გასაგები უნდა იყოს, რომ ნამუშევარი ზუსტად იგივეა, რაც მარტივი Segment Tree-ში, მაგრამ მნიშვნელობების შეჯამების/მინიმიზაციის/მაქსიმიზაციის ნაცვლად ვიყენებთ $\text{combine}$ ფუნქციას.

```{.cpp file=segment_tree_maximal_sum_subsegments3}
data query(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return make_data(0);
    if (l == tl && r == tr) 
        return t[v];
    int tm = (tl + tr) / 2;
    return combine(query(v*2, tl, tm, l, min(r, tm)), 
                   query(v*2+1, tm+1, tr, max(l, tm+1), r));
}
```

### <a name="saving-the-entire-subarrays-in-each-vertex"></a> მთელი ქვემასივების შენახვა თითოეულ წვეროში

ეს არის ცალკე ქვეგანყოფილება, რომელიც განცალკევებულია სხვებისგან, რადგან სეგმენტის ხის თითოეულ წვეროზე ჩვენ არ ვინახავთ ინფორმაციას შესაბამისი სეგმენტის შესახებ შეკუმშული სახით (ჯამ, მინიმალური, მაქსიმუმი, ...), არამედ ვინახავთ ყველა ელემენტს. სეგმენტი.
ამრიგად, სეგმენტის ხის ფესვი შეინახავს მასივის ყველა ელემენტს, მარცხენა შვილობილი წვერო შეინახავს მასივის პირველ ნახევარს, მარჯვენა წვეროს მეორე ნახევარს და ა.შ.

ამ ტექნიკის უმარტივესი გამოყენებისას ჩვენ ვინახავთ ელემენტებს დალაგებული თანმიმდევრობით.
უფრო რთულ ვერსიებში ელემენტები არ ინახება სიებში, არამედ უფრო მოწინავე მონაცემთა სტრუქტურები (კომპლექტები, რუკები, ...).
მაგრამ ყველა ამ მეთოდს აქვს საერთო ფაქტორი, რომ თითოეული წვერო მოითხოვს ხაზოვან მეხსიერებას (ანუ შესაბამისი სეგმენტის სიგრძის პროპორციულად).

პირველი ბუნებრივი კითხვა ამ სეგმენტური ხეების განხილვისას არის მეხსიერების მოხმარება.
ინტუიციურად ეს შეიძლება გამოიყურებოდეს $O(n^2)$ მეხსიერებას, მაგრამ გამოდის, რომ სრულ ხეს მხოლოდ $O(n \log n)$ მეხსიერება დასჭირდება.
რატომ არის ეს ასე?
უბრალოდ, რადგან მასივის თითოეული ელემენტი ხვდება $O(\log n)$ სეგმენტებში (გახსოვდეთ, რომ ხის სიმაღლეა $O(\log n)$).

ასე რომ, მიუხედავად ასეთი სეგმენტური ხის აშკარა ექსტრავაგანტულისა, ის მხოლოდ ოდნავ მეტ მეხსიერებას მოიხმარს, ვიდრე ჩვეულებრივი სეგმენტის ხე.

ამ მონაცემთა სტრუქტურის რამდენიმე ტიპიური პროგრამა აღწერილია ქვემოთ.
აღსანიშნავია ამ სეგმენტური ხეების მსგავსება 2D მონაცემთა სტრუქტურებთან (სინამდვილეში ეს არის 2D მონაცემთა სტრუქტურა, მაგრამ საკმაოდ შეზღუდული შესაძლებლობებით).

#### იპოვეთ მითითებულ რიცხვზე დიდი ან ტოლი უმცირესი რიცხვი. მოდიფიკაციის მოთხოვნები არ არის.

ჩვენ გვინდა ვუპასუხოთ შეკითხვებს შემდეგი ფორმის მიხედვით:
სამი მოცემული რიცხვისთვის $(l, r, x)$ უნდა ვიპოვოთ მინიმალური რიცხვი $a[l \dots r]$ სეგმენტში, რომელიც მეტია ან ტოლია $x$-ის.

ჩვენ ვაშენებთ სეგმენტის ხეს.
თითოეულ წვეროში ჩვენ ვინახავთ ყველა რიცხვის დახარისხებულ სიას, რომლებიც გვხვდება შესაბამის სეგმენტში, როგორც ზემოთ აღწერილი.
როგორ ავაშენოთ ასეთი სეგმენტის ხე რაც შეიძლება ეფექტურად?
როგორც ყოველთვის, ამ პრობლემას რეკურსიულად მივუდგებით: მოდით, უკვე აშენდეს მარცხენა და მარჯვენა ბავშვების სიები და გვინდა ავაშენოთ სია მიმდინარე წვეროსთვის.
ამ თვალსაზრისით, ოპერაცია ახლა ტრივიალურია და შეიძლება განხორციელდეს ხაზოვან დროში:
ჩვენ მხოლოდ უნდა გავაერთიანოთ ორი დახარისხებული სია ერთში, რაც შეიძლება გაკეთდეს მათზე გამეორებით ორი მაჩვენებლის გამოყენებით.
C++ STL-ს უკვე აქვს ამ ალგორითმის განხორციელება.

იმის გამო, რომ სეგმენტის ხის ეს სტრუქტურა და შერწყმის დალაგების ალგორითმის მსგავსება, მონაცემთა სტრუქტურას ასევე ხშირად უწოდებენ "Merge Sort Tree".


```{.cpp file=segment_tree_smallest_number_greater1}
vector<int> t[4*MAXN];

void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = vector<int>(1, a[tl]);
    } else { 
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        merge(t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),
              back_inserter(t[v]));
    }
}
```

ჩვენ უკვე ვიცით, რომ ამ გზით აგებული სეგმენტის ხე მოითხოვს $O(n \log n)$ მეხსიერებას.
და ამ განხორციელების წყალობით, მის კონსტრუქციას ასევე სჭირდება $O(n \log n)$ დრო, ყოველივე ამის შემდეგ თითოეული სია აგებულია წრფივ დროში მისი ზომის მიხედვით.

ახლა განიხილეთ კითხვაზე პასუხი.
ჩვენ ჩამოვალთ ხეზე, როგორც ჩვეულებრივ Segment Tree-ში, და დავყოფთ $a[l \dots r]$ სეგმენტად რამდენიმე ქვესეგმენტად (მაქსიმუმ $O(\log n)$ ნაწილებად).
ნათელია, რომ მთელი პასუხის პასუხი არის თითოეული ქვემოთხოვნის მინიმალური.
ახლა ჩვენ მხოლოდ უნდა გავიგოთ, როგორ ვუპასუხოთ შეკითხვას ერთ ასეთ ქვესეგმენტზე, რომელიც შეესაბამება ხის ზოგიერთ წვეროს.

ჩვენ ვართ სეგმენტის ხის რაღაც წვეროზე და გვინდა გამოვთვალოთ პასუხი შეკითხვაზე, ანუ ვიპოვოთ მინიმალური რიცხვი იმაზე მეტი ან ტოლი მოცემული $x$ რიცხვისა.
ვინაიდან წვერო შეიცავს ელემენტების ჩამონათვალს დალაგებული თანმიმდევრობით, ჩვენ შეგვიძლია უბრალოდ შევასრულოთ ორობითი ძებნა ამ სიაში და დავაბრუნოთ პირველი რიცხვი, რომელიც მეტია ან ტოლია $x$-ზე.

ამგვარად, ხის ერთ სეგმენტში შეკითხვაზე პასუხის გაცემას $O(\log n)$ დრო სჭირდება და მთელი შეკითხვა დამუშავდება $O(\log^2 n)$-ში.

```{.cpp file=segment_tree_smallest_number_greater2}
int query(int v, int tl, int tr, int l, int r, int x) {
    if (l > r)
        return INF;
    if (l == tl && r == tr) {
        vector<int>::iterator pos = lower_bound(t[v].begin(), t[v].end(), x);
        if (pos != t[v].end())
            return *pos;
        return INF;
    }
    int tm = (tl + tr) / 2;
    return min(query(v*2, tl, tm, l, min(r, tm), x), 
               query(v*2+1, tm+1, tr, max(l, tm+1), r, x));
}
```

მუდმივი $\text{INF}$ უდრის რაღაც დიდ რიცხვს, რომელიც აღემატება მასივის ყველა რიცხვს.
მისი გამოყენება ნიშნავს, რომ სეგმენტში არ არის $x$-ზე მეტი ან ტოლი რიცხვი.
მას აქვს მნიშვნელობა "მოცემულ ინტერვალში პასუხი არ არის".

#### იპოვეთ მითითებულ რიცხვზე დიდი ან ტოლი უმცირესი რიცხვი. მოდიფიკაციის მოთხოვნებით.

ეს ამოცანა წინას მსგავსია.
ბოლო მიდგომას აქვს მინუსი, შეუძლებელი იყო მასივის შეცვლა შეკითხვებზე პასუხებს შორის.
ახლა ჩვენ გვინდა გავაკეთოთ ზუსტად ეს: მოდიფიკაციის მოთხოვნა შეასრულებს დავალებას $a[i] = y$.

გამოსავალი წინა პრობლემის გადაჭრის მსგავსია, მაგრამ სიების ნაცვლად სეგმენტის ხის თითოეულ წვეროზე, ჩვენ შევინახავთ დაბალანსებულ სიას, რომელიც საშუალებას გაძლევთ სწრაფად მოძებნოთ რიცხვები, წაშალოთ რიცხვები და ჩადოთ ახალი რიცხვები.
ვინაიდან მასივი შეიძლება შეიცავდეს განმეორებით რიცხვს, ოპტიმალური არჩევანია მონაცემთა სტრუქტურა $\text{multiset}$.

ასეთი სეგმენტის ხის აგება ხდება თითქმის ისევე, როგორც წინა პრობლემაში, მხოლოდ ახლა ჩვენ უნდა გავაერთიანოთ $\text{multiset}$s და არა დახარისხებული სიები.
ეს იწვევს $O(n \log^2 n)$-ის მშენებლობის დროს (ზოგადად ორი წითელ-შავი ხის შერწყმა შეიძლება გაკეთდეს წრფივ დროში, მაგრამ C++ STL არ იძლევა ამ დროის სირთულის გარანტიას).

$\text{query}$ ფუნქცია ასევე თითქმის ექვივალენტია, მხოლოდ ახლა უნდა გამოიძახოთ $\text{lower_bound}$ ფუნქცია $\text{multiset}$ ($\text{std::lower_bound}$ მუშაობს მხოლოდ $O(\log n)$ დროში, თუ გამოიყენება შემთხვევითი წვდომის იტერატორებით).

ბოლოს მოდიფიკაციის მოთხოვნა.
მის დასამუშავებლად უნდა ჩავიდეთ ხეზე და შევცვალოთ ყველა $\text{multiset}$ შესაბამისი სეგმენტებიდან, რომლებიც შეიცავს დაზარალებულ ელემენტს.
ჩვენ უბრალოდ ვშლით ამ ელემენტის ძველ მნიშვნელობას (მაგრამ მხოლოდ ერთ შემთხვევას) და ჩავსვით ახალი მნიშვნელობა.

```cpp
void update(int v, int tl, int tr, int pos, int new_val) {
    t[v].erase(t[v].find(a[pos]));
    t[v].insert(new_val);
    if (tl != tr) {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
    } else {
        a[pos] = new_val;
    }
}
```

ამ მოდიფიკაციის მოთხოვნის დამუშავებას ასევე $O(\log^2 n)$ დრო სჭირდება.

#### იპოვეთ მითითებულ რიცხვზე დიდი ან ტოლი უმცირესი რიცხვი. აჩქარება "ფრაქციული კასკადით".

ჩვენ გვაქვს იგივე პრობლემის ფორმულირება, გვინდა ვიპოვოთ მინიმალური რიცხვი $x$-ზე მეტი ან ტოლი სეგმენტში, მაგრამ ამჯერად $O(\log n)$ დროში.
ჩვენ გავაუმჯობესებთ დროის სირთულეს ტექნიკის "ფრაქციული კასკადის" გამოყენებით.

ფრაქციული კასკადი არის მარტივი ტექნიკა, რომელიც საშუალებას გაძლევთ გააუმჯობესოთ მრავალჯერადი ორობითი ძიების დრო, რომლებიც ერთდროულად ტარდება.
ჩვენი წინა მიდგომა საძიებო მოთხოვნის მიმართ იყო ის, რომ ჩვენ დავყავით დავალება რამდენიმე ქვეამოცანად, რომელთაგან თითოეული წყდება ბინარული ძიებით.
ფრაქციული კასკადური საშუალებას გაძლევთ შეცვალოთ ყველა ეს ბინარული ძიება ერთით.

წილადური კასკადის უმარტივესი და აშკარა მაგალითია შემდეგი პრობლემა:
არის $k$ დახარისხებული რიცხვების სიები და თითოეულ სიაში უნდა ვიპოვოთ მოცემულ რიცხვზე მეტი ან ტოლი პირველი რიცხვი.

იმის ნაცვლად, რომ განვახორციელოთ ორობითი ძებნა თითოეული სიისთვის, ჩვენ შეგვიძლია გავაერთიანოთ ყველა სია ერთ დიდ დახარისხებულ სიაში.
დამატებით თითოეული $y$ ელემენტისთვის ჩვენ ვინახავთ $y$-ის ძიების შედეგების სიას თითოეულ $k$ სიაში.
ამიტომ, თუ გვსურს ვიპოვოთ უმცირესი რიცხვი $x$-ზე მეტი ან ტოლი, ჩვენ უბრალოდ უნდა ჩავატაროთ ერთი ორობითი ძებნა და ინდექსების სიიდან შეგვიძლია განვსაზღვროთ უმცირესი რიცხვი თითოეულ სიაში.
თუმცა ეს მიდგომა მოითხოვს $O(n \cdot k)$ ($n$ არის კომბინირებული სიების სიგრძე), რაც შეიძლება საკმაოდ არაეფექტური იყოს.

ფრაქციული კასკადური მეხსიერების სირთულის შემცირება $O(n)$ მეხსიერებამდე, $k$ შეყვანის სიებიდან $k$ ახალი სიების შექმნით, რომელშიც თითოეული სია შეიცავს შესაბამის სიას და დამატებით ასევე მომდევნო ახალი სიის ყოველ მეორე ელემენტს.
ამ სტრუქტურის გამოყენებით საჭიროა მხოლოდ ორი ინდექსის შენახვა, ელემენტის ინდექსი თავდაპირველ სიაში და ელემენტის ინდექსი შემდეგ ახალ სიაში.
ასე რომ, ეს მიდგომა იყენებს მხოლოდ $O(n)$ მეხსიერებას და მაინც შეუძლია უპასუხოს შეკითხვებს ერთი ორობითი ძიების გამოყენებით.

მაგრამ ჩვენი აპლიკაციისთვის არ გვჭირდება წილადის კასკადის სრული სიმძლავრე.
ჩვენს სეგმენტის ხეში წვერო შეიცავს ყველა ელემენტის დახარისხებულ სიას, რომლებიც გვხვდება მარცხენა ან მარჯვენა ქვეხეებში (როგორც შერწყმის დახარისხების ხეში).
ამ დახარისხებული სიის გარდა, ჩვენ ვინახავთ ორ პოზიციას თითოეული ელემენტისთვის.
$y$ ელემენტისთვის ჩვენ ვინახავთ უმცირეს ინდექსს $i$, ისე, რომ $i$th ელემენტი მარცხენა ბავშვის დახარისხებულ სიაში არის $y$-ის დიდი ან ტოლი.
და ჩვენ ვინახავთ უმცირეს ინდექსს $j$, ისე, რომ $j$th ელემენტი სწორი ბავშვის დახარისხებულ სიაში იყოს $y$-ის დიდი ან ტოლი.
ეს მნიშვნელობები შეიძლება გამოითვალოს შერწყმის ნაბიჯის პარალელურად, როდესაც ჩვენ ვაშენებთ ხეს.

როგორ აჩქარებს ეს შეკითხვებს?

დაიმახსოვრეთ, ნორმალურ გადაწყვეტაში ჩვენ გავაკეთეთ ორობითი ძებნა ყველა კვანძში.
მაგრამ ამ მოდიფიკაციით ჩვენ შეგვიძლია თავიდან ავიცილოთ ყველა, გარდა ერთისა.

შეკითხვაზე პასუხის გასაცემად, ჩვენ უბრალოდ ვაკეთებთ ბინარულ ძიებას root კვანძში.
ეს გვაძლევს უმცირეს ელემენტს $y \ge x$ სრულ მასივში, მაგრამ ასევე გვაძლევს ორ პოზიციას.
უმცირესი ელემენტის ინდექსი უფრო დიდი ან ტოლია $x$ მარცხენა ქვეხეში და უმცირესი $y$ ელემენტის ინდექსი მარჯვენა ქვეხეში. გაითვალისწინეთ, რომ $\ge y$ იგივეა, რაც $\ge x$, რადგან ჩვენი მასივი არ შეიცავს ელემენტებს $x$-სა და $y$-ს შორის.
ჩვეულებრივ Merge Sort Tree ხსნარში ჩვენ გამოვთვლით ამ ინდექსებს ორობითი ძიების საშუალებით, მაგრამ წინასწარ გამოთვლილი მნიშვნელობების დახმარებით ჩვენ შეგვიძლია უბრალოდ მოვიძიოთ ისინი $O(1)$-ში.
და ჩვენ შეგვიძლია გავიმეოროთ ეს მანამ, სანამ არ მოვინახულებთ ყველა კვანძს, რომელიც მოიცავს ჩვენი შეკითხვის ინტერვალს.

შეჯამებისთვის, ჩვეულებისამებრ, შეკითხვის დროს ვეხებით $O(\log n)$ კვანძებს. ძირეულ კვანძში ვაკეთებთ ბინარულ ძიებას, ხოლო ყველა სხვა კვანძში მხოლოდ მუდმივ მუშაობას.
ეს ნიშნავს, რომ შეკითხვაზე პასუხის სირთულე არის $O(\log n)$.

მაგრამ გაითვალისწინეთ, რომ ეს იყენებს სამჯერ მეტ მეხსიერებას, ვიდრე ჩვეულებრივი Merge Sort Tree, რომელიც უკვე იყენებს ბევრ მეხსიერებას ($O(n \log n)$).

მარტივია ამ ტექნიკის გამოყენება პრობლემაზე, რომელიც არ საჭიროებს რაიმე სახის მოდიფიკაციის მოთხოვნას.
ორი პოზიცია მხოლოდ მთელი რიცხვია და ადვილად შეიძლება გამოითვალოს დათვლით ორი დალაგებული მიმდევრობის შერწყმისას.

ჯერ კიდევ შესაძლებელია მოდიფიკაციის მოთხოვნების დაშვება, მაგრამ ეს ართულებს მთელ კოდს.
მთელი რიცხვების ნაცვლად, თქვენ უნდა შეინახოთ დახარისხებული მასივი, როგორც `multisset`, ხოლო ინდექსების ნაცვლად თქვენ უნდა შეინახოთ iterators.
და თქვენ უნდა იმუშაოთ ძალიან ფრთხილად, ისე, რომ გაზარდოთ ან შეამციროთ სწორი იტერატორები მოდიფიკაციის მოთხოვნის დროს.

#### სხვა შესაძლო ვარიაციები

ეს ტექნიკა გულისხმობს შესაძლო აპლიკაციების სრულიად ახალ კლასს.
იმის ნაცვლად, რომ შეინახოთ $\text{vector}$ ან $\text{multiset}$ თითოეულ წვეროში, შეიძლება გამოყენებულ იქნას სხვა მონაცემთა სტრუქტურები:
სხვა სეგმენტური ხეები (განსაკუთრებით განხილულია [განზოგადება უფრო მაღალ განზომილებამდე](segment_tree.md#generalization-to-higher-dimensions)), ფენვიკის ხეები, დეკარტის ხეები და ა.შ.

### დიაპაზონის განახლებები (ზარმაცი გავრცელება)

ზემოაღნიშნული განყოფილებების ყველა პრობლემა განიხილებოდა მოდიფიკაციის მოთხოვნებს, რომლებიც გავლენას ახდენდნენ მასივის მხოლოდ ერთ ელემენტზე.
თუმცა სეგმენტის ხე იძლევა მოდიფიკაციის მოთხოვნების გამოყენებას მომიჯნავე ელემენტების მთელ სეგმენტზე და შეასრულოს მოთხოვნა ერთდროულად $O(\log n)$.


#### დამატება სეგმენტებზე

ჩვენ ვიწყებთ უმარტივესი ფორმის პრობლემების განხილვით: მოდიფიკაციის მოთხოვნამ უნდა დაამატოს $x$ რიცხვი ყველა რიცხვს სეგმენტში $a[l \dots r]$.
მეორე შეკითხვაზე, რომელსაც ჩვენ უნდა ვუპასუხოთ, ითხოვდა უბრალოდ $a[i]$-ის მნიშვნელობას.

იმისათვის, რომ შეკრების მოთხოვნა ეფექტური იყოს, თითოეულ წვეროზე სეგმენტის ხეზე ვინახავთ რამდენი უნდა დავუმატოთ ყველა რიცხვს შესაბამის სეგმენტში.
მაგალითად, თუ დადგება მოთხოვნა "დაამატე 3 მთელ მასივს $a[0 \წერტილები n-1]$", მაშინ ხის ძირში ვათავსებთ რიცხვს 3.
ზოგადად, ჩვენ უნდა მოვათავსოთ ეს რიცხვი მრავალ სეგმენტზე, რომლებიც ქმნიან მოთხოვნის სეგმენტის დანაყოფს.
ამრიგად, ჩვენ არ უნდა შევცვალოთ $O(n)$-ის ყველა მნიშვნელობა, არამედ მხოლოდ $O(\log n)$ ბევრი.

თუ ახლა დადგება შეკითხვა, რომელიც ითხოვს კონკრეტული მასივის ჩანაწერის მიმდინარე მნიშვნელობას, საკმარისია ჩახვიდეთ ხეზე და დაამატოთ გზაზე ნაპოვნი ყველა მნიშვნელობა.

```cpp
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = 0;
    }
}

void update(int v, int tl, int tr, int l, int r, int add) {
    if (l > r)
        return;
    if (l == tl && r == tr) {
        t[v] += add;
    } else {
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), add);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, add);
    }
}

int get(int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return t[v] + get(v*2, tl, tm, pos);
    else
        return t[v] + get(v*2+1, tm+1, tr, pos);
}
```

#### დავალება სეგმენტებზე

დავუშვათ, რომ მოდიფიკაციის მოთხოვნა ითხოვს $a[l \dots r]$-ის გარკვეული სეგმენტის თითოეული ელემენტის მინიჭებას $p$-ის მნიშვნელობისთვის.
როგორც მეორე შეკითხვა, ჩვენ კვლავ განვიხილავთ $a[i]$ მასივის მნიშვნელობის წაკითხვას.

ამ მოდიფიკაციის მოთხოვნის შესასრულებლად მთელ სეგმენტზე, თქვენ უნდა შეინახოთ სეგმენტის ხის თითოეულ წვეროზე, დაფარულია თუ არა შესაბამისი სეგმენტი მთლიანად იგივე მნიშვნელობით.
ეს საშუალებას გვაძლევს გავაკეთოთ "ზარმაცი" განახლება:
იმის ნაცვლად, რომ შევცვალოთ ხეში ყველა სეგმენტი, რომელიც ფარავს მოთხოვნის სეგმენტს, ჩვენ მხოლოდ ზოგიერთს ვცვლით და ზოგს უცვლელად ვტოვებთ.
მონიშნული წვერო ნიშნავს, რომ შესაბამისი სეგმენტის ყველა ელემენტი ენიჭება ამ მნიშვნელობას და რეალურად ასევე სრული ქვეხე უნდა შეიცავდეს მხოლოდ ამ მნიშვნელობას.
გარკვეული გაგებით, ჩვენ ზარმაცი ვართ და ვაჭიანებთ ახალი მნიშვნელობის ჩაწერას ყველა იმ წვეროზე.
ჩვენ შეგვიძლია მოგვიანებით გავაკეთოთ ეს დამღლელი დავალება, თუ ეს საჭირო იქნება.

ასე რომ, მოდიფიკაციის მოთხოვნის შესრულების შემდეგ, ხის ზოგიერთი ნაწილი ხდება შეუსაბამო - ზოგიერთი მოდიფიკაცია მასში შეუსრულებელი რჩება.

მაგალითად, თუ შესრულდება მოდიფიკაციის მოთხოვნა "მთელ მასივს $a[0 \წერტილები n-1]$" რიცხვის მინიჭება, სეგმენტის ხეში მხოლოდ ერთი ცვლილება ხდება - რიცხვი მოთავსებულია ხის ძირში. და ეს წვერო აღინიშნება.
დარჩენილი სეგმენტები უცვლელი რჩება, თუმცა ფაქტიურად რიცხვი უნდა განთავსდეს მთელ ხეში.

დავუშვათ, რომ მეორე მოდიფიკაციის მოთხოვნა ამბობს, რომ $a[0 \dots n/2]$ მასივის პირველ ნახევარს უნდა მიენიჭოს სხვა რიცხვი.
ამ მოთხოვნის დასამუშავებლად ჩვენ უნდა მივაკუთვნოთ თითოეულ ელემენტს ფესვის წვეროს მთელ მარცხენა შვილში ამ რიცხვთან.
მაგრამ სანამ ამას გავაკეთებთ, ჯერ უნდა დავახარისხოთ ფესვის წვერო.
დახვეწილობა აქ არის ის, რომ მასივის მარჯვენა ნახევარი მაინც უნდა მიენიჭოს პირველი მოთხოვნის მნიშვნელობას და ამ მომენტში არ არის შენახული ინფორმაცია მარჯვენა ნახევრის შესახებ.

ამის გადაჭრის გზა არის ფესვის ინფორმაციის მიწოდება მის შვილებზე, ანუ თუ ხის ფესვს მიენიჭა რაიმე რიცხვი, მაშინ ამ რიცხვს მივაკუთვნებთ მარცხენა და მარჯვენა შვილეულ წვეროებს და ამოვიღებთ ფესვის ნიშანს. .
ამის შემდეგ, ჩვენ შეგვიძლია მივაკუთვნოთ მარცხენა შვილს ახალი მნიშვნელობა, საჭირო ინფორმაციის დაკარგვის გარეშე.

შეჯამებით ვიღებთ:
ნებისმიერი შეკითხვისთვის (მოდიფიკაცია ან კითხვა) ხის გასწვრივ დაღმართის დროს ჩვენ ყოველთვის უნდა გადავიტანოთ ინფორმაცია მიმდინარე წვეროდან მის ორივე შვილში.
ჩვენ შეგვიძლია გავიგოთ ეს ისე, რომ ხეზე ჩამოსვლისას ვაკეთებთ დაგვიანებულ მოდიფიკაციებს, ოღონდ ზუსტად იმდენს, რამდენიც საჭიროა (რათა არ დავამციროთ $O(\log n)$-ის სირთულე).

განხორციელებისთვის ჩვენ უნდა შევქმნათ $\text{push}$ ფუნქცია, რომელიც მიიღებს მიმდინარე წვეროს და ის გადასცემს ინფორმაციას მისი წვეროსთვის ორივე შვილზე.
ჩვენ მოვუწოდებთ ამ ფუნქციას მოთხოვნის ფუნქციების დასაწყისში (მაგრამ არ გამოვიძახებთ მას ფოთლებიდან, რადგან არ არის საჭირო ინფორმაციის შემდგომი გადატანა).

```cpp
void push(int v) {
    if (marked[v]) {
        t[v*2] = t[v*2+1] = t[v];
        marked[v*2] = marked[v*2+1] = true;
        marked[v] = false;
    }
}

void update(int v, int tl, int tr, int l, int r, int new_val) {
    if (l > r) 
        return;
    if (l == tl && tr == r) {
        t[v] = new_val;
        marked[v] = true;
    } else {
        push(v);
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), new_val);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, new_val);
    }
}

int get(int v, int tl, int tr, int pos) {
    if (tl == tr) {
        return t[v];
    }
    push(v);
    int tm = (tl + tr) / 2;
    if (pos <= tm) 
        return get(v*2, tl, tm, pos);
    else
        return get(v*2+1, tm+1, tr, pos);
}
```
შენიშვნა: ფუნქცია $\text{get}$ ასევე შეიძლება განხორციელდეს სხვაგვარად:
ნუ გააკეთებთ დაგვიანებულ განახლებებს, მაგრამ დაუყოვნებლივ დააბრუნეთ $t[v]$ მნიშვნელობა, თუ $marked[v]$ მართალია.

#### სეგმენტების დამატება, მაქსიმუმის მოთხოვნა

ახლა მოდიფიკაციის მოთხოვნა არის დიაპაზონის ყველა ელემენტისთვის რიცხვის დამატება, ხოლო კითხვის მოთხოვნა არის მაქსიმალური დიაპაზონის პოვნა.

ასე რომ, სეგმენტის ხის თითოეული წვეროსთვის უნდა შევინახოთ შესაბამისი ქვესეგმენტის მაქსიმუმი.
საინტერესო ნაწილია, თუ როგორ უნდა გამოვთვალოთ ეს მნიშვნელობები მოდიფიკაციის მოთხოვნის დროს.

ამ მიზნით ჩვენ ვინახავთ დამატებით მნიშვნელობას თითოეული წვეროსთვის.
ამ მნიშვნელობაში ჩვენ ვინახავთ დამატებებს, რომლებიც არ გავავრცელეთ ბავშვის წვეროებზე.
ბავშვის წვეროზე გადასვლამდე ჩვენ ვუწოდებთ $\text{push}$-ს და ვავრცელებთ მნიშვნელობას ორივე ბავშვზე.
ეს უნდა გავაკეთოთ როგორც $\text{update}$ ფუნქციაში, ასევე $\text{query}$ ფუნქციაში.

```cpp
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = max(t[v*2], t[v*2 + 1]);
    }
}

void push(int v) {
    t[v*2] += lazy[v];
    lazy[v*2] += lazy[v];
    t[v*2+1] += lazy[v];
    lazy[v*2+1] += lazy[v];
    lazy[v] = 0;
}

void update(int v, int tl, int tr, int l, int r, int addend) {
    if (l > r) 
        return;
    if (l == tl && tr == r) {
        t[v] += addend;
        lazy[v] += addend;
    } else {
        push(v);
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), addend);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);
        t[v] = max(t[v*2], t[v*2+1]);
    }
}

int query(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return -INF;
    if (l == tl && tr == r)
        return t[v];
    push(v);
    int tm = (tl + tr) / 2;
    return max(query(v*2, tl, tm, l, min(r, tm)), 
               query(v*2+1, tm+1, tr, max(l, tm+1), r));
}
```

### <a name="generalization-to-higher-dimensions"></a> განზოგადება უფრო მაღალ ზომებზე

სეგმენტის ხე შეიძლება განზოგადდეს საკმაოდ ბუნებრივად უფრო მაღალ ზომებზე.
თუ ერთგანზომილებიან შემთხვევაში მასივის ინდექსებს ვყოფთ სეგმენტებად, მაშინ ორგანზომილებიანში ვაკეთებთ ჩვეულებრივ სეგმენტის ხეს პირველ ინდექსებთან მიმართებაში და თითოეული სეგმენტისთვის ვაშენებთ ჩვეულებრივ სეგმენტის ხეს. მეორე ინდექსები.

#### მარტივი 2D სეგმენტის ხე

მოცემულია $a[0 \dots n-1, 0 \dots m-1]$ მატრიცა და უნდა ვიპოვოთ ჯამი (ან მინიმალური/მაქსიმუმი) ზოგიერთ ქვემატრიცაზე $a[x_1 \წერტილები x_2, y_1 \წერტილები. y_2]$, ასევე შეასრულეთ ინდივიდუალური მატრიცის ელემენტების ცვლილებები (ანუ $a[x][y] = p$ ფორმის მოთხოვნები).

ასე რომ, ჩვენ ვაშენებთ 2D სეგმენტის ხეს: ჯერ სეგმენტის ხე პირველი კოორდინატის გამოყენებით ($x$), შემდეგ მეორე ($y$).

მშენებლობის პროცესი უფრო გასაგები რომ გახდეს, შეგიძლიათ ცოტა ხნით დაივიწყოთ, რომ მატრიცა ორგანზომილებიანია და მხოლოდ პირველი კოორდინატი დატოვოთ.
ჩვენ ავაშენებთ ჩვეულებრივ ერთგანზომილებიან სეგმენტურ ხეს მხოლოდ პირველი კოორდინატის გამოყენებით.
მაგრამ იმის ნაცვლად, რომ შეინახოთ რიცხვი სეგმენტში, ჩვენ ვინახავთ მთელ სეგმენტის ხეს:
ანუ ამ მომენტში გვახსოვს, რომ გვაქვს მეორე კოორდინატიც; მაგრამ რადგან ამ მომენტში პირველი კოორდინატი უკვე ფიქსირდება რაღაც $[l \dots r]$ ინტერვალზე, ჩვენ რეალურად ვმუშაობთ ასეთ ზოლთან $a[l \dots r, 0 \dots m-1]$ და ამისათვის ჩვენ სეგმენტის ხის აშენება.

აქ არის 2D სეგმენტის ხის კონსტრუქციის განხორციელება.
ის რეალურად წარმოადგენს ორ ცალკეულ ბლოკს:
სეგმენტის ხის აგება $x$ კოორდინატის ($\text{build}_x$) და $y$ კოორდინატის ($\text{build}_y$) გასწვრივ.
ფოთლოვანი კვანძებისთვის $\text{build}_y$-ში უნდა გამოვყოთ ორი შემთხვევა:
როდესაც $[tlx \dots trx]$-ის პირველი კოორდინატის მიმდინარე სეგმენტს აქვს სიგრძე 1 და როდესაც მას აქვს სიგრძე ერთზე მეტი. პირველ შემთხვევაში, ჩვენ უბრალოდ ვიღებთ შესაბამის მნიშვნელობას მატრიციდან, ხოლო მეორე შემთხვევაში შეგვიძლია გავაერთიანოთ ორი სეგმენტური ხეების მნიშვნელობები მარცხნიდან და მარჯვენა son კოორდინატში $x$.

```cpp
void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {
    if (ly == ry) {
        if (lx == rx)
            t[vx][vy] = a[lx][ly];
        else
            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
    } else {
        int my = (ly + ry) / 2;
        build_y(vx, lx, rx, vy*2, ly, my);
        build_y(vx, lx, rx, vy*2+1, my+1, ry);
        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
    }
}

void build_x(int vx, int lx, int rx) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        build_x(vx*2, lx, mx);
        build_x(vx*2+1, mx+1, rx);
    }
    build_y(vx, lx, rx, 1, 0, m-1);
}
```

ასეთი სეგმენტის ხე კვლავ იყენებს მეხსიერების ხაზოვან რაოდენობას, მაგრამ უფრო დიდი მუდმივით: $16 n m$.
გასაგებია, რომ აღწერილი პროცედურა $\text{build}_x$ ასევე მუშაობს ხაზოვან დროში.

ახლა ჩვენ მივმართავთ მოთხოვნების დამუშავებას. ჩვენ ვუპასუხებთ ორგანზომილებიან შეკითხვას იგივე პრინციპით:
ჯერ შეწყვიტეთ მოთხოვნა პირველ კოორდინატზე, შემდეგ კი ყოველი მიღწეული წვეროსთვის ჩვენ ვუწოდებთ მეორე კოორდინატის შესაბამის სეგმენტის ხეს.

```cpp
int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {
    if (ly > ry) 
        return 0;
    if (ly == tly && try_ == ry)
        return t[vx][vy];
    int tmy = (tly + try_) / 2;
    return sum_y(vx, vy*2, tly, tmy, ly, min(ry, tmy))
         + sum_y(vx, vy*2+1, tmy+1, try_, max(ly, tmy+1), ry);
}

int sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
    if (lx > rx)
        return 0;
    if (lx == tlx && trx == rx)
        return sum_y(vx, 1, 0, m-1, ly, ry);
    int tmx = (tlx + trx) / 2;
    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry)
         + sum_x(vx*2+1, tmx+1, trx, max(lx, tmx+1), rx, ly, ry);
}
```

ეს ფუნქცია მუშაობს $O(\log n \log m)$ დროში, რადგან ის ჯერ ეშვება ხეზე პირველ კოორდინატში და ხეში ყოველი გადაკვეთილი წვეროსთვის ის აკეთებს შეკითხვას შესაბამის სეგმენტის ხეში მეორე კოორდინატთან ერთად.

საბოლოოდ განვიხილავთ მოდიფიკაციის მოთხოვნას.
ჩვენ გვსურს ვისწავლოთ როგორ შევცვალოთ სეგმენტის ხე $a[x][y] = p$ ზოგიერთი ელემენტის მნიშვნელობის ცვლილების შესაბამისად.
ნათელია, რომ ცვლილებები მოხდება მხოლოდ პირველი სეგმენტის ხის იმ წვეროებზე, რომლებიც ფარავს კოორდინატს $x$ (და ასეთი იქნება $O(\log n)$), ხოლო მათ შესაბამისი სეგმენტის ხეებისთვის ცვლილებები მოხდება. ხდება მხოლოდ იმ წვეროებზე, რომლებიც ფარავს კოორდინატს $y$ (და ასეთი იქნება $O(\log m)$).
ამიტომ განხორციელება არც თუ ისე განსხვავებული იქნება ერთგანზომილებიანი შემთხვევისგან, მხოლოდ ახლა ჩვენ ჯერ პირველ კოორდინატზე ჩამოვდივართ, შემდეგ კი მეორეზე.

```cpp
void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {
    if (ly == ry) {
        if (lx == rx)
            t[vx][vy] = new_val;
        else
            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
    } else {
        int my = (ly + ry) / 2;
        if (y <= my)
            update_y(vx, lx, rx, vy*2, ly, my, x, y, new_val);
        else
            update_y(vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);
        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
    }
}

void update_x(int vx, int lx, int rx, int x, int y, int new_val) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        if (x <= mx)
            update_x(vx*2, lx, mx, x, y, new_val);
        else
            update_x(vx*2+1, mx+1, rx, x, y, new_val);
    }
    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);
}
```

#### 2D სეგმენტის ხის შეკუმშვა

დაე, პრობლემა იყოს შემდეგი: სიბრტყეზე არის $n$ პუნქტები, რომლებიც მოცემულია მათი კოორდინატებით $(x_i, y_i)$ და მოთხოვნები ფორმის "დათვალეთ მართკუთხედში $((x_1, y_1) მდებარე წერტილების რაოდენობა. (x_2, y_2))$".
ცხადია, რომ ასეთი პრობლემის შემთხვევაში უსაფუძვლოდ ფუჭი ხდება $O(n^2)$ ელემენტებით ორგანზომილებიანი სეგმენტის ხის აგება.
ამ მეხსიერების უმეტესი ნაწილი დაიკარგება, რადგან თითოეული წერტილი შეიძლება მოხვდეს ხის მხოლოდ $O(\log n)$ სეგმენტებში პირველი კოორდინატის გასწვრივ და, შესაბამისად, მეორე კოორდინატზე ყველა ხის სეგმენტის ჯამური "სასარგებლო" ზომაა. $O(n \log n)$.

ასე რომ, ჩვენ ვაგრძელებთ შემდეგნაირად:
სეგმენტის ხის თითოეულ წვეროზე პირველ კოორდინატთან მიმართებაში ჩვენ ვინახავთ სეგმენტის ხეს, რომელიც აგებულია მხოლოდ იმ მეორე კოორდინატებით, რომლებიც გვხვდება პირველი კოორდინატების მიმდინარე სეგმენტში.
სხვა სიტყვებით რომ ვთქვათ, სეგმენტის ხის აგებისას რომელიმე წვეროში $vx$ ინდექსით და $tlx$ და $trx$ საზღვრებით, ჩვენ განვიხილავთ მხოლოდ იმ წერტილებს, რომლებიც მოხვდება ამ ინტერვალში $x \in [tlx, trx]$ და შექმენით სეგმენტის ხე მხოლოდ მათი გამოყენებით.

ამრიგად, ჩვენ მივაღწევთ იმას, რომ მეორე კოორდინატზე თითოეული სეგმენტის ხე დაიკავებს ზუსტად იმდენ მეხსიერებას, რამდენიც უნდა.
შედეგად, მეხსიერების მთლიანი რაოდენობა შემცირდება $O(n \log n)$-მდე.
ჩვენ კვლავ შეგვიძლია ვუპასუხოთ შეკითხვებს $O(\log^2 n)$ დროში, უბრალოდ უნდა გავაკეთოთ ორობითი ძებნა მეორე კოორდინატზე, მაგრამ ეს არ გააუარესებს სირთულეს.

მაგრამ მოდიფიკაციის მოთხოვნები შეუძლებელი იქნება ამ სტრუქტურით:
რეალურად, თუ ახალი წერტილი გამოჩნდება, ჩვენ უნდა დავამატოთ ახალი ელემენტი ზოგიერთი სეგმენტის ხის შუაში მეორე კოორდინატის გასწვრივ, რაც ეფექტურად ვერ ხერხდება.

დასასრულს აღვნიშნავთ, რომ აღწერილი გზით შეკუმშული ორგანზომილებიანი სეგმენტის ხე პრაქტიკულად ექვივალენტური ხდება ერთგანზომილებიანი სეგმენტის ხის მოდიფიკაციისა (იხ.[Saving the entire subarrays in each vertex](segment_tree.md#saving-the-entire-subarrays-in-each-vertex)).
კერძოდ, ორგანზომილებიანი სეგმენტის ხე არის მხოლოდ სპეციალური შემთხვევა ხის თითოეულ წვეროში ქვემწვავის შესანახად.
აქედან გამომდინარეობს, რომ თუ თქვენ დათმობთ ორგანზომილებიან სეგმენტურ ხეს მოთხოვნის შესრულების შეუძლებლობის გამო, აზრი აქვს შეეცადოთ შეცვალოთ ჩადგმული სეგმენტის ხე უფრო მძლავრი მონაცემთა სტრუქტურით, მაგალითად, კარტეზიული ხე.

### მისი ღირებულებების ისტორიის შენარჩუნება (მუდმივი სეგმენტის ხე)

მუდმივი მონაცემთა სტრუქტურა არის მონაცემთა სტრუქტურა, რომელიც ახსოვს მის წინა მდგომარეობას თითოეული მოდიფიკაციისთვის.
ეს საშუალებას გაძლევთ შეხვიდეთ ამ მონაცემთა სტრუქტურის ნებისმიერ ვერსიაზე, რომელიც გვაინტერესებს და შეასრულოთ მასზე მოთხოვნა.

სეგმენტის ხე არის მონაცემთა სტრუქტურა, რომელიც შეიძლება ეფექტურად იქცეს მონაცემთა მუდმივ სტრუქტურად (როგორც დროში, ასევე მეხსიერების მოხმარებაში).
ჩვენ გვსურს თავიდან ავიცილოთ სრული ხის კოპირება ყოველი მოდიფიკაციის წინ და არ გვინდა დავკარგოთ $O(\log n)$ დროის ქცევა დიაპაზონის შეკითხვებზე პასუხის გასაცემად.

ფაქტობრივად, ნებისმიერი ცვლილების მოთხოვნა სეგმენტის ხეში იწვევს მხოლოდ $O(\log n)$ წვეროების მონაცემების ცვლილებას ფესვიდან დაწყებული ბილიკის გასწვრივ.
ასე რომ, თუ სეგმენტის ხეს ვინახავთ პოინტერების გამოყენებით (ანუ წვერო ინახავს მაჩვენებლებს მარცხნივ და მარჯვენა ბავშვის წვეროებზე), მაშინ მოდიფიკაციის მოთხოვნის შესრულებისას, ხელმისაწვდომი წვეროების შეცვლის ნაცვლად, უბრალოდ უნდა შევქმნათ ახალი წვეროები.
წვეროები, რომლებზეც გავლენას არ ახდენს მოდიფიკაციის მოთხოვნა, კვლავ შეიძლება გამოყენებულ იქნას მაჩვენებლების ძველ წვეროებზე მითითებით.
ამრიგად, $O(\log n)$ მოდიფიკაციის მოთხოვნისთვის შეიქმნება ახალი წვეროები, სეგმენტის ხის ახალი ძირის წვეროს ჩათვლით, და ხის მთელი წინა ვერსია, რომელიც ფესვის ძველ წვეროზეა დაფუძნებული, უცვლელი დარჩება.

მოდით მოვიყვანოთ უმარტივესი სეგმენტის ხის განხორციელების მაგალითი: როდესაც არის მხოლოდ მოთხოვნა, რომელიც ითხოვს თანხებს და მოდიფიცირებული მოთხოვნები ცალკეული ელემენტების შესახებ.

```cpp
struct Vertex {
    Vertex *l, *r;
    int sum;

    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}
    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {
        if (l) sum += l->sum;
        if (r) sum += r->sum;
    }
};

Vertex* build(int a[], int tl, int tr) {
    if (tl == tr)
        return new Vertex(a[tl]);
    int tm = (tl + tr) / 2;
    return new Vertex(build(a, tl, tm), build(a, tm+1, tr));
}

int get_sum(Vertex* v, int tl, int tr, int l, int r) {
    if (l > r)
        return 0;
    if (l == tl && tr == r)
        return v->sum;
    int tm = (tl + tr) / 2;
    return get_sum(v->l, tl, tm, l, min(r, tm))
         + get_sum(v->r, tm+1, tr, max(l, tm+1), r);
}

Vertex* update(Vertex* v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        return new Vertex(new_val);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);
    else
        return new Vertex(v->l, update(v->r, tm+1, tr, pos, new_val));
}
```

სეგმენტის ხის ყოველი მოდიფიკაციისთვის ჩვენ მივიღებთ ახალ ფესვის წვეროს.
Segment Tree-ის ორ განსხვავებულ ვერსიას შორის სწრაფად გადახტომისთვის, ჩვენ უნდა შევინახოთ ეს ფესვები მასივში.
სეგმენტის ხის კონკრეტული ვერსიის გამოსაყენებლად ჩვენ უბრალოდ ვუწოდებთ შეკითხვას შესაბამისი ძირეული წვერის გამოყენებით.

ზემოთ აღწერილი მიდგომით, თითქმის ნებისმიერი სეგმენტის ხე შეიძლება გადაიქცეს მონაცემთა მუდმივ სტრუქტურად.

#### $k$-th უმცირესი რიცხვის პოვნა დიაპაზონში

ამჯერად ჩვენ უნდა ვუპასუხოთ კითხვებს ფორმის „რა არის $k$-th ყველაზე პატარა ელემენტი $a[l \dots r]$ დიაპაზონში.
ამ შეკითხვაზე პასუხის გაცემა შესაძლებელია ორობითი ძიების და Merge Sort Tree-ის გამოყენებით, მაგრამ ერთი მოთხოვნის დროის სირთულე იქნება $O(\log^3 n)$.
ჩვენ შევასრულებთ იგივე ამოცანას მუდმივი სეგმენტის ხის გამოყენებით $O(\log n)$-ში.

პირველ რიგში განვიხილავთ უფრო მარტივი პრობლემის გადაწყვეტას:
ჩვენ განვიხილავთ მხოლოდ მასივებს, რომლებშიც ელემენტები შეკრულია $0 \le a[i] \lt n$-ით.
ჩვენ გვსურს ვიპოვოთ $k$-th უმცირესი ელემენტი $a$ მასივის ზოგიერთ პრეფიქსში.
ძალიან ადვილი იქნება შემდგომში განვითარებული იდეების გაფართოება შეუზღუდავი მასივების და არა შეზღუდული დიაპაზონის მოთხოვნებისთვის.
გაითვალისწინეთ, რომ ჩვენ გამოვიყენებთ 1 დაფუძნებულ ინდექსირებას $a$-ად.

ჩვენ გამოვიყენებთ სეგმენტის ხეს, რომელიც ითვლის ყველა გამოჩენილ რიცხვს, ანუ სეგმენტის ხეში ვინახავთ მასივის ჰისტოგრამას.
ასე რომ, ფოთლის წვეროები შეინახავს რამდენად ხშირად გამოჩნდება მასივში მნიშვნელობები $0$, $1$, $\dots$, $n-1$, ხოლო სხვა წვეროები ინახავს რამდენი რიცხვია მასივში რაღაც დიაპაზონში.
სხვა სიტყვებით რომ ვთქვათ, ჩვენ ვქმნით რეგულარულ სეგმენტურ ხეს ჯამის მოთხოვნებით მასივის ჰისტოგრამაზე.
მაგრამ იმის ნაცვლად, რომ შევქმნათ $n$ სეგმენტის ხეები ყველა შესაძლო პრეფიქსისთვის, ჩვენ შევქმნით ერთ მუდმივ, რომელიც შეიცავს იგივე ინფორმაციას.
ჩვენ დავიწყებთ ცარიელი სეგმენტის ხით (ყველა რაოდენობა იქნება $0$), რომელზეც მითითებულია $root_0$ და დავამატებთ ელემენტებს $a[1]$, $a[2]$, $\dots$, $a[n ]$ ერთმანეთის მიყოლებით.
ყოველი მოდიფიკაციისთვის ჩვენ მივიღებთ ახალ root წვეროს, მოდით ვუწოდოთ $root_i$ სეგმენტის ხის ფესვი მასივის $a$ პირველი $i$ ელემენტების ჩასმის შემდეგ.
$root_i$-ზე დაფუძნებული სეგმენტის ხე შეიცავს $a[1 \dots i]$ პრეფიქსის ჰისტოგრამას.
ამ სეგმენტის ხის გამოყენებით $O(\log n)$-ში შეგვიძლია ვიპოვოთ $k$-th ელემენტის პოზიცია იმავე ტექნიკის გამოყენებით, რომელიც განხილულია [ნულების რაოდენობის დათვლა, $k$-th ნულის ძიება](segment_tree.md#counting-zero-search-kth).

ახლა გადადით პრობლემის შეუზღუდავ ვერსიაზე.

პირველ რიგში, შეკითხვებზე შეზღუდვისთვის:
იმის ნაცვლად, რომ შეასრულოთ ეს მოთხოვნები მხოლოდ $a$-ის პრეფიქსით, ჩვენ გვინდა გამოვიყენოთ ნებისმიერი თვითნებური სეგმენტი $a[l \dots r]$.
აქ ჩვენ გვჭირდება სეგმენტის ხე, რომელიც წარმოადგენს $a[l \dots r]$ დიაპაზონის ელემენტების ჰისტოგრამას.
ადვილი მისახვედრია, რომ ასეთი სეგმენტური ხე არის განსხვავება $root_{r}$-ზე დაფუძნებულ სეგმენტის ხესა და $root_{l-1}$-ზე დაფუძნებულ სეგმენტის ხეს შორის, ანუ ყველა წვეროზე $[l \. წერტილები r]$ სეგმენტის ხე შეიძლება გამოითვალოს $root_{r}$ ხის წვერით გამოკლებული $root_{l-1}$ ხის წვერო.

$\text{find_kth}$ ფუნქციის განხორციელებისას, ეს შეიძლება დამუშავდეს ორი წვეროს მაჩვენებლის გადაცემით და მიმდინარე სეგმენტის რაოდენობა/ჯამის გამოთვლა, როგორც წვეროების ორი დათვლის/ჯამების სხვაობა.

აქ არის შეცვლილი $\text{build}$, $\text{update}$ და $\text{find_kth}$ ფუნქციები

```{.cpp file=kth_smallest_persistent_segment_tree}
Vertex* build(int tl, int tr) {
    if (tl == tr)
        return new Vertex(0);
    int tm = (tl + tr) / 2;
    return new Vertex(build(tl, tm), build(tm+1, tr));
}

Vertex* update(Vertex* v, int tl, int tr, int pos) {
    if (tl == tr)
        return new Vertex(v->sum+1);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return new Vertex(update(v->l, tl, tm, pos), v->r);
    else
        return new Vertex(v->l, update(v->r, tm+1, tr, pos));
}

int find_kth(Vertex* vl, Vertex *vr, int tl, int tr, int k) {
    if (tl == tr)
    	return tl;
    int tm = (tl + tr) / 2, left_count = vr->l->sum - vl->l->sum;
    if (left_count >= k)
    	return find_kth(vl->l, vr->l, tl, tm, k);
    return find_kth(vl->r, vr->r, tm+1, tr, k-left_count);
}
```

როგორც უკვე დავწერე ზემოთ, ჩვენ უნდა შევინახოთ საწყისი სეგმენტის ხის ფესვი და ასევე ყველა ფესვი ყოველი განახლების შემდეგ.
აქ არის კოდი მუდმივი სეგმენტის ხის შესაქმნელად ვექტორზე `a` ელემენტებით `[0, MAX_VALUE]` დიაპაზონში.

```{.cpp file=kth_smallest_persistent_segment_tree_build}
int tl = 0, tr = MAX_VALUE + 1;
std::vector<Vertex*> roots;
roots.push_back(build(tl, tr));
for (int i = 0; i < a.size(); i++) {
    roots.push_back(update(roots.back(), tl, tr, a[i]));
}

// იპოვეთ მე-5 უმცირესი რიცხვი ქვემასივიდან [a[2], a[3], ..., a[19]]
int result = find_kth(roots[2], roots[20], tl, tr, 5);
```

ახლა მასივის ელემენტებზე შეზღუდვებს:
ჩვენ შეგვიძლია რეალურად გარდაქმნათ ნებისმიერი მასივი ასეთ მასივში ინდექსის შეკუმშვით.
მასივის ყველაზე პატარა ელემენტს მიენიჭება მნიშვნელობა 0, მეორე ყველაზე პატარას მნიშვნელობა 1 და ა.შ.
ადვილია საძიებო ცხრილების გენერირება (მაგ. $\text{map}$-ის გამოყენებით), რომელიც გადააქცევს მნიშვნელობას მის ინდექსში და პირიქით $O(\log n)$ დროში.

### დინამიური სეგმენტის ხე

(ასე უწოდებენ, რადგან მისი ფორმა დინამიურია და კვანძები ჩვეულებრივ დინამიურად არის გამოყოფილი.
ასევე ცნობილია როგორც _ იმპლიციტური სეგმენტის ხე_ ან _ იშვიათი სეგმენტის ხე_.)

ადრე განვიხილავდით შემთხვევებს, როდესაც გვაქვს ორიგინალური სეგმენტის ხის აგების შესაძლებლობა. მაგრამ რა უნდა გააკეთოს, თუ თავდაპირველი ზომა ივსება ნაგულისხმევი ელემენტით, მაგრამ მისი ზომა არ გაძლევთ საშუალებას, რომ სრულად შეადგინოთ იგი წინასწარ?

ამ პრობლემის გადაჭრა შეგვიძლია სეგმენტის ხის ზარმაცი (ნამატებით) შექმნით. თავდაპირველად ჩვენ შევქმნით მხოლოდ ფესვს, ხოლო დანარჩენ წვეროებს მხოლოდ მაშინ შევქმნით, როცა დაგვჭირდება.
ამ შემთხვევაში, ჩვენ გამოვიყენებთ იმპლემენტაციას პოინტერებზე (სანამ წვეროებზე გადავალთ, შეამოწმეთ არის თუ არა ისინი შექმნილი და თუ არა, შექმენით ისინი).
თითოეულ მოთხოვნას ჯერ კიდევ აქვს მხოლოდ $O(\log n)$ სირთულე, რომელიც საკმარისად მცირეა გამოყენების შემთხვევების უმეტესობისთვის (მაგ. $\log_2 10^9 \დაახლოებით 30$).

ამ დანერგვისას ჩვენ გვაქვს ორი მოთხოვნა, ვამატებთ მნიშვნელობას პოზიციაზე (თავდაპირველად ყველა მნიშვნელობა არის $0$) და გამოითვლება ყველა მნიშვნელობის ჯამი დიაპაზონში.
` Vertex(0, n)` იქნება იმპლიციტური ხის ძირეული წვერო.

```cpp
struct Vertex {
    int left, right;
    int sum = 0;
    Vertex *left_child = nullptr, *right_child = nullptr;

    Vertex(int lb, int rb) {
        left = lb;
        right = rb;
    }

    void extend() {
        if (!left_child && left + 1 < right) {
            int t = (left + right) / 2;
            left_child = new Vertex(left, t);
            right_child = new Vertex(t, right);
        }
    }

    void add(int k, int x) {
        extend();
        sum += x;
        if (left_child) {
            if (k < left_child->right)
                left_child->add(k, x);
            else
                right_child->add(k, x);
        }
    }

    int get_sum(int lq, int rq) {
        if (lq <= left && right <= rq)
            return sum;
        if (max(left, lq) >= min(right, rq))
            return 0;
        extend();
        return left_child->get_sum(lq, rq) + right_child->get_sum(lq, rq);
    }
};
```

ცხადია, ეს იდეა შეიძლება გავრცელდეს სხვადასხვა გზით. Მაგალითად. დიაპაზონის განახლებების მხარდაჭერის დამატებით ზარმაცი გამრავლების საშუალებით.

## სავარჯიშო

* [SPOJ - KQUERY](http://www.spoj.com/problems/KQUERY/) [Persistent segment tree / Merge sort tree]
* [Codeforces - Xenia and Bit Operations](https://codeforces.com/problemset/problem/339/D)
* [UVA 11402 - Ahoy, Pirates!](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2397)
* [SPOJ - GSS3](http://www.spoj.com/problems/GSS3/)
* [Codeforces - Distinct Characters Queries](https://codeforces.com/problemset/problem/1234/D)
* [Codeforces - Knight Tournament](https://codeforces.com/contest/356/problem/A) [For beginners]
* [Codeforces - Ant colony](https://codeforces.com/contest/474/problem/F)
* [Codeforces - Drazil and Park](https://codeforces.com/contest/515/problem/E)
* [Codeforces - Circular RMQ](https://codeforces.com/problemset/problem/52/C)
* [Codeforces - Lucky Array](https://codeforces.com/contest/121/problem/E)
* [Codeforces - The Child and Sequence](https://codeforces.com/contest/438/problem/D)
* [Codeforces - DZY Loves Fibonacci Numbers](https://codeforces.com/contest/446/problem/C) [Lazy propagation]
* [Codeforces - Alphabet Permutations](https://codeforces.com/problemset/problem/610/E)
* [Codeforces - Eyes Closed](https://codeforces.com/problemset/problem/895/E)
* [Codeforces - Kefa and Watch](https://codeforces.com/problemset/problem/580/E)
* [Codeforces - A Simple Task](https://codeforces.com/problemset/problem/558/E)
* [Codeforces - SUM and REPLACE](https://codeforces.com/problemset/problem/920/F)
* [Codeforces - XOR on Segment](https://codeforces.com/problemset/problem/242/E) [Lazy propagation]
* [Codeforces - Please, another Queries on Array?](https://codeforces.com/problemset/problem/1114/F) [Lazy propagation]
* [COCI - Deda](https://oj.uz/problem/view/COCI17_deda) [Last element smaller or equal to x / Binary search]
* [Codeforces - The Untended Antiquity](https://codeforces.com/problemset/problem/869/E) [2D]
* [CSES - Hotel Queries](https://cses.fi/problemset/task/1143)
* [CSES - Polynomial Queries](https://cses.fi/problemset/task/1736)
* [CSES - Range Updates and Sums](https://cses.fi/problemset/task/1735)

