## საფუძვლები
### კვადრატული სიმძლავრე

ორობითი სიძლიერე (ასევე ცნობილია, როგორც კვადრატული სიმძლავრე) არის ხრიკი, რომელიც საშუალებას გვაძლევს გამოთვალოთ $(a^n)$ მხოლოდ $O(\log n)$ ოპერაციაში (ნაცვლად $O(n)$ ).

მას ასევე აქვს მნიშვნელოვანი როლი არითმეტიკასთან დაკავშირებულ ბევრ ამოცანაში, რადგან ის
შეიძლება გამოყენებულ იქნას ნებისმიერი ოპერაციაში, რომელსაც აქვს თვისება **ასოციაციურობა**:

$$(X \cdot Y) \cdot Z = X \cdot (Y \cdot Z)$$

ყველაზე აშკარად ეს ეხება მოდულურ გამრავლებას, მატრიცების გამრავლებას და სხვა ამოცანებს, რომლებსაც ქვემოთ განვიხილავთ.

#### ალგორითმი
$a$-ს აწევა $n$-ის ხარისხზე ჩვეულებრივ გამოიხატება, როგორც $a$-ს გამრავლება $n-1$ ჯერ:
$a^{n} = a \cdot a \cdot \ldots \cdot a$. თუმცა ეს მიდგომა არ არის პრაქტიკული დიდი $a$ ან $n$ თვის.

$a^{b+c} = a^b \cdot a^c$ და $a^{2b} = a^b \cdot a^b = (a^b)^2$.

ორობითი სიძლიერის იდეა არის ის, რომ ჩვენ ვყოფთ სამუშაოს ექსპონენტის ორობითი წარმოდგენის გამოყენებით.

მოდი დავწეროთ $n$-ი 2-ის ფუძით (ორობითში), მაგალითად:

$$3^{13} = 3^{1101_2} = 3^8 \cdot 3^4 \cdot 3^1$$

ნომრიდან გამომდინარე $n$-ს აქვს ზუსტად $\lfloor \log_2 n \rfloor + 1$ ციფრი 2-ის ფუძით, ჩვენ მხოლოდ $O(\log n)$ გამრავლება გვჭირდება, თუ ჩვენ ვიცით ხარისხები $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log n \rfloor}}$.

ასე რომ, ჩვენ მხოლოდ უნდა ვიცოდეთ მათი გამოთვლის სწრაფი გზა. საბედნიეროდ, ეს ძალიან მარტივია, რადგან ელემენტი თანმიმდევრობით არის მხოლოდ წინა ელემენტის კვადრატი.

$$\begin{align}
3^1 &= 3 \\
3^2 &= \left(3^1\right)^2 = 3^2 = 9 \\
3^4 &= \left(3^2\right)^2 = 9^2 = 81 \\
3^8 &= \left(3^4\right)^2 = 81^2 = 6561
\end{align}$$

ამიტომ საბოლოო პასუხის მისაღებად $3^{13}$, ჩვენ მხოლოდ სამი მათგანი უნდა გავამრავლოთ (გამოვტოვოთ $3^2$ რადგან შესაბამისი ბიტი $n$-ისთვის არის 0):

$3^{13} = 6561 \cdot 81 \cdot 3 = 1594323$

ამ ალგორითმის საბოლოო სირთულე არის $O(\log n)$: ჩვენ უნდა გამოვთვალოთ $\log n$ სიმძლავრეები $a$-ზე და შემდეგ უნდა გავაკეთოთ მაქსიმუმ $\log n$ გამრავლება, რომ მივიღოთ საბოლოო პასუხი.

მოცემული რეკურსიული მიდგომა გამოხატავს იმავე აზრს:

$$a^n = \begin{cases}
1 &\text{if } n == 0 \\
\left(a^{\frac{n}{2}}\right)^2 &\text{if } n > 0 \text{ and } n \text{ even}\\
\left(a^{\frac{n - 1}{2}}\right)^2 \cdot a &\text{if } n > 0 \text{ and } n \text{ odd}\\
\end{cases}$$

#### განხორციელება

პირველი რეკურსიული მიდგომა, რომელიც არის რეკურსიული ფორმულის პირდაპირი თარგმანი:

```cpp
long long binpow(long long a, long long b) {
    if (b == 0)
        return 1;
    long long res = binpow(a, b / 2);
    if (b % 2)
        return res * res * a;
    else
        return res * res;
}
```

მეორე მიდგომა ასრულებს იგივე ამოცანას რეკურსიის გარეშე.
ის გამოითვლის ყველა ხარისხს ციკლში და ამრავლებს ერთეულებს შესაბამისი კომპლექტის ბიტით $n$-ში.
მიუხედავად იმისა, რომ ორივე მიდგომის სირთულე იდენტურია, ეს მიდგომა პრაქტიკაში უფრო სწრაფი იქნება, რადგან ჩვენ არ ვიყენებთ რეკურსიულ გამოძახებას რამაც შეიძლება დაამატოს დამატებითი დამუშავების დრო

```cpp
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
```
### ევკლიდური ალგორითმი უდიდესი საერთო გამყოფის გამოსათვლელად
ორი არაუარყოფითი მთელი რიცხვის $a$ და $b$-ის გათვალისწინებით, ჩვენ უნდა ვიპოვოთ მათი ყველაზე დიდი საერთო გამყოფი **GCD** (greatest common divisor).
ის ჩვეულებრივ აღინიშნება $\gcd(a, b)$. მათემატიკურად ის განისაზღვრება, როგორც:

$$\gcd(a, b) = \max \{k > 0 : (k \mid a) \text{ and } (k \mid b) \}$$

(აქ სიმბოლო "$\mid$" ნიშნავს გაყოფას, ანუ, "$k \mid a$" ნიშნავს "$k$ ყოფს $a$")

როდესაც რიცხვებიდან ერთი არის ნულოვანი, ხოლო მეორე არა-ნულოვანი, მათი ყველაზე დიდი საერთო გამყოფი, განსაზღვრებით, არის მეორე რიცხვი. როდესაც ორივე რიცხვი ნულის ტოლია, მათი უდიდესი საერთო გამყოფი განუსაზღვრელია(undefined) (ეს შეიძლება იყოს ნებისმიერი თვითნებურად დიდი რიცხვი), მაგრამ მოსახერხებელია მისი განსაზღვრა როგორც ნული, ასევე $\gcd$-ის ასოციაციურობის შესანარჩუნებლად. რაც გვაძლევს მარტივ წესს: თუ რიცხვებიდან ერთი არის ნული, ყველაზე დიდი საერთო გამყოფი არის მეორე რიცხვი.


ქვემოთ განხილული ევკლიდური ალგორითმი საშუალებას იძლევა ვიპოვოთ, $a$ და $b$ ორი რიცხვის უდიდესი საერთო გამყოფი $O(\log \min(a, b))$-ში.

#### ალგორითმი

თავდაპირველად, ევკლიდეს ალგორითმი ჩამოყალიბებული იყო შემდეგნაირად: გამოაკელით პატარა რიცხვი დიდს, სანამ ერთ-ერთი რიცხვი ნულის ტოლი იქნება. მართლაც, თუ $g$ ყოფს $a$-ს და $b$-ს, ის ასევე ყოფს $a-b$. მეორეს მხრივ, თუ $g$ ყოფს $a-b$-ს და $b$-ს, ის ასევე ყოფს $a = b + (a-b)$, რაც ნიშნავს, რომ $\{a, b\}$-ის საერთო გამყოფების სიმრავლეები და $\{b,a-b\}$ ემთხვევა.

გაითვალისწინეთ, რომ $a$ რჩება უფრო დიდ რიცხვად, სანამ $b$ არ გამოაკლდება მას $\left\lfloor\frac{a}{b}\right\rfloor$-ჯერ მაინც. ამიტომ, საქმეების დასაჩქარებლად, $a-b$ ჩანაცვლებულია $a-\left\lfloor\frac{a}{b}\right\rfloor b = a \bmod b$. შემდეგ ალგორითმი ჩამოყალიბებულია ძალიან მარტივი გზით:

$$\gcd(a, b) = \begin{cases}a,&\text{if }b = 0 \\ \gcd(b, a \bmod b),&\text{otherwise.}\end{cases}$$

#### განხორციელება

```cpp
int gcd (int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd (b, a % b);
}
```

სამმაგი ოპერატორის დახმარებით C++-ში შეგვიძლია ჩავწეროთ როგორც ერთხაზოვანი.

```cpp
int gcd (int a, int b) {
    return b ? gcd (b, a % b) : a;
}
```

და ბოლოს, აქ არის არარეკურსიული განხორციელება:

```cpp
int gcd (int a, int b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

გაითვალისწინეთ, რომ C++17-დან, `gcd` დანერგილია როგორც [სტანდარტული ფუნქცია](https://en.cppreference.com/w/cpp/numeric/gcd) C++ -ში.

#### დროის სირთულე

ალგორითმის მუშაობის დრო ფასდება ლამეს თეორემით, რომელიც ადგენს გასაოცარ კავშირს ევკლიდეს ალგორითმსა და ფიბონაჩის მიმდევრობას შორის:

თუ $a > b \geq 1$ და $b < F_n$ ზოგიერთი $n$-ისთვის, ევკლიდური ალგორითმი ასრულებს მაქსიმუმ $n-2$ რეკურსიულ გამოძახებას.

უფრო მეტიც, შესაძლებელია იმის ჩვენება, რომ ამ თეორემის ზედა ზღვარი ოპტიმალურია. როდესაც $a = F_n$ და $b = F_{n-1}$, $gcd(a, b)$ შეასრულებს ზუსტად $n-2$ რეკურსიულ ზარებს. სხვა სიტყვებით რომ ვთქვათ, თანმიმდევრული ფიბონაჩის რიცხვები ევკლიდეს ალგორითმის ყველაზე ცუდი შემთხვევის შეყვანაა.

იმის გათვალისწინებით, რომ ფიბონაჩის რიცხვები ექსპონენციალურად იზრდება, მივიღებთ, რომ ევკლიდეს ალგორითმი მუშაობს $O(\log \min(a,b))$-ში.

სირთულის შეფასების კიდევ ერთი გზაა შეამჩნიოთ, რომ $a \bmod b$ შემთხვევისთვის $a \geq b$ მინიმუმ $2$-ჯერ ნაკლებია $a$-ზე, ასე რომ, უფრო დიდი რიცხვი მცირდება მინიმუმ ნახევრჯერ ალგორითმის ყოველ გამეორებაზე.

### უმცირესი საერთო ჯერადი

უმცირესი საერთო ჯერადი (საყოველთაოდ აღინიშნა LCM) გამოთვლა შეიძლება შემცირდეს GCD-ის გამოანგარიშებამდე შემდეგი მარტივი ფორმულით:

$$\text{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)}$$

ამრიგად, LCM შეიძლება გამოითვალოს ევკლიდეს ალგორითმის გამოყენებით იგივე დროის სირთულით:

შესაძლო იმპლემენტაცია, რომელიც ჭკვიანურად თავიდან აიცილებს რიცხვების გადატვირთვას(Integer overflow), პირველად $a$-ის გაყოფით GCD-ზე, მოცემულია აქ:

```cpp
int lcm (int a, int b) {
    return a / gcd(a, b) * b;
}
```

### ორობითი (Binary) GCD

